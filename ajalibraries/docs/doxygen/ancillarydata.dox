/**
@page	ancillarydata	Ancillary Data

Traditionally, AJA's NTV2 devices processed active video and ancillary data using separate data paths in the hardware.
This is still very much the case, although the introduction of the Anc inserter/extractor firmware has created further
options.

<b>CONTENTS:</b>
-	\ref ancembeddedaudio
-	\ref anctimecode
	-	\ref anctimecodeinput
	-	\ref anctimecodeoutput
	-	\ref ancanalogltcinput
	-	\ref ancanalogltcoutput
-	\ref ancvpid
-	\ref anccapture
-	\ref ancplayout
-	\ref ancgumpformat
-	\ref ancrtpformat
-	\ref vancframegeometries


@section	ancembeddedaudio	Embedded Audio

Embedded audio in HANC is handled by the Audio System(s) in firmware — see \ref audiooperation for more information.

Devices that have <b>Anc Extractor</b> firmware are able to capture the “raw” audio packets from HANC … then decode
them per SMPTE/AES specifications.  See \ref anccapture (below) for information on how to do this.

<hr size="50px">


@section	anctimecode		Timecode (RP-188, SMPTE-12M)

The timecode aspects of NTV2’s SDK and firmware has its origins in the early 2000s — when NTV2 devices were SD-only, and the
SMPTE 12M spec was still evolving. FPGA space was very tight in those days, including the number of registers available … which
is one reason why the same registers were used for RP-188 capture and playout.

-	Two 32-bit registers are required to store a timecode value:
	-	one for the low-order 32 bits;
	-	another for the high-order 32 bits
-	An extra register is used to hold the extra “Distributed Binary Bits” (DBB) information per SMPTE 12M and RP-188.
-	In the SDK, these three register values are represented by the ::NTV2_RP188 data type, and the older ::RP188_STRUCT data type.

On older devices (i.e. those that <i>don’t</i> support “stacked audio” — see ::NTV2DeviceCanDoStackedAudio) and those <i>without</i>
bidirectional SDI connectors (see ::NTV2DeviceHasBiDirectionalSDI), one general-purpose register triplet is used to store an SDI
input’s timecode <b><i>and also</i></b> provide a place to specify a timecode for SDI output. In other words, one register triplet
is used for reading a timecode from, say, SDI In 1 <i>and</i> for writing a timecode to, say, SDI Out 1. The Hi/Lo-order
general-purpose timecode registers are “write-only” for SDI output;  and “read-only” for SDI input. In other words, reading those
registers yields the received input timecode, while writing those registers sets the output (playout) timecode.

@note	This inability to read back what’s been written into the register is very different behavior from nearly all other NTV2
		registers. For devices that follow this old model, it’s impossible to fetch the output timecode value that was written
		for playout. So beware that when CNTV2Card::SetRP188Data is called on these older devices, it’s not possible to find out
		what was “set”, since CNTV2Card::GetRP188Data is always reading the SDI input’s timecode.

On newer devices that have bi-directional SDI connectors (i.e. both ::NTV2DeviceCanDoStackedAudio and ::NTV2DeviceHasBiDirectionalSDI
return <tt>true</tt>), CNTV2Card::GetRP188Data will return the corresponding SDI output’s timecode if the SDI spigot is configured
for output (see CNTV2Card::SetSDITransmitEnable).

For End-to-End (E-E) mode, i.e. when an SDI input is connected directly to an SDI output, to pass through timecode obtained
from an SDI input…
-	Call CNTV2Card::EnableRP188Bypass to have the SDI output’s timecode embedder <i>not</i> use the RP188 registers, but
	instead use timecode obtained from an SDI input.
-	Call CNTV2Card::SetRP188BypassSource to specify which SDI input to use.
-	Call CNTV2Card::SetRP188SourceFilter to specify which input timecode to use — e.g. 0 for LTC, 1 for VITC1, etc.


@subsection		anctimecodeinput		Embedded SDI Timecode Input

Any RP-188 data in the SDI input video with DBB-1 data matching the input’s current RP-188 source select filter (see
CNTV2Card::SetRP188SourceFilter) will be placed into the input’s RP-188 registers.

There are two ways to receive input timecode:
-	When using \ref autocirculatecapture, do the following:
	-	Pass ::AUTOCIRCULATE_WITH_RP188 to CNTV2Card::AutoCirculateInitForInput;
	-	While processing frames, call CNTV2Card::AutoCirculateTransfer;
	-	Call AUTOCIRCULATE_TRANSFER::GetInputTimeCodes, and look for the RP-188 timecode(s) of interest…
		-	in the ::NTV2TimeCodes map, or…
		-	in the ::NTV2TimeCodeList vector.
-	Without \ref aboutautocirculate, use either of these two methods:
	-	Call CNTV2Card::GetRP188Data (shortly after the input VBI) for the SDI Input of interest, using the DBB filter
		to choose the timecode of interest (LTC, VITC1, VITC2 … see CNTV2Card::SetRP188SourceFilter ).
		-	There are extra bits in NTV2_RP188::fDBB that indicate what was received:
			-	<tt>BIT(16)</tt>: If set, indicates RP-188 is being received.
			-	<tt>BIT(17)</tt>: Valid when RP-188 filtering is in-play (see CNTV2Card::SetRP188SourceFilter):
				If set, indicates the requested (filtered) RP-188 has been received.
			-	<tt>BIT(18)</tt>: If set, indicates ATC/LTC was received.
			-	<tt>BIT(19)</tt>: If set, indicates VITC was received.
	-	Or use the <b>Anc Extractor</b> firmware described in \ref anccapture (below) to capture the “raw” HANC timecode
		packet data … then decode it per the SMPTE specifications.

@note	<b>Regarding High Frame Rates (>30fps):</b> When reading timecode for any input faster than 30fps,
		you’ll see a duplicate frame count in two successive frames — but in the latter frame, the field bit will be set,
		and the DBB will indicate a value of 0x02 (VITC2). This is the SMPTE ST-12M-preferred way of sending >30fps timecode.
		The 12M specification says there are systems that won’t conform to this transmission convention, so receivers
		that want to support them will need to be flexible.


@par	Example: Capturing Embedded SDI Timecode Without AutoCirculate

<b>SetUpRP188</b>

@code{.cpp}
static const ULWord  gChToRP188DBBRegNum[] = {  kRegRP188InOut1DBB,  kRegRP188InOut2DBB,  kRegRP188InOut3DBB,  kRegRP188InOut4DBB,
                                                kRegRP188InOut5DBB,  kRegRP188InOut6DBB,  kRegRP188InOut7DBB,  kRegRP188InOut8DBB,  0};

bool SetUpRP188 (CNTV2Card & inCard)
{
    const NTV2DeviceID  deviceID        (inCard.GetDeviceID());
    const bool          isKonaLHi       (deviceID == DEVICE_ID_KONALHI);
    ULWord              userDefinedDBB  (0);

    for (NTV2Channel ch(NTV2_CHANNEL1);  ch < NTV2Channel(::NTV2DeviceGetNumVideoOutputs(deviceID));  ch = NTV2Channel(ch + 1))
    {
        inCard.SetRP188Mode (ch, NTV2_RP188_OUTPUT);
        inCard.ReadRegister (kVRegUserDefinedDBB, userDefinedDBB);
        if (!userDefinedDBB == 0)
        {
            ULWord inputFilter (0x00);
            if (::NTV2DeviceCanDoVITC2(deviceID))
                inputFilter = 0x02;
            else if (!isKonaLHi)
                inputFilter = 0x01;
            inCard.WriteRegister (gChToRP188DBBRegNum[i],  inputFilter,  ULWord(kRegMaskRP188SourceSelect),  kRegShiftRP188Source);
            inCard.WriteRegister (gChToRP188DBBRegNum[i],  isKonaLHi ? 0x00 : 0xFF,  kRegMaskRP188DBB,  kRegShiftRP188DBB);
        }
    }  //  for each SDI connector

    if (::NTV2DeviceCanDoWidget(m_DeviceID, NTV2_WgtSDIMonOut1))
    {
        inCard.SetRP188Mode (NTV2_CHANNEL5, NTV2_RP188_OUTPUT);
        inCard.ReadRegister (kVRegUserDefinedDBB, userDefinedDBB);
        if (!userDefinedDBB)
            inCard.WriteRegister (gChToRP188DBBRegNum[NTV2_CHANNEL5], 0xFF, kRegMaskRP188DBB, kRegShiftRP188DBB);
    }
}  //  SetUpRP188
@endcode

<b>GetReceivedTCForChannel</b>

@code{.cpp}
bool GetReceivedTCForChannel (CNTV2Card & inCard, const NTV2Channel inChannel, NTV2_RP188 & outReceivedLTC, RP188_STRUCT & outReceivedVITC1, RP188_STRUCT & outReceivedVITC2)
{
    ULWord  receivedAnyRP188  (0);
    ULWord  receivedLTC       (0);
    ULWord  receivedVITC1     (0);
    ULWord  receivedVITC2     (0);
    ULWord  inputFilter       (0x02);
    NTV2VideoFormat    channelFormat (NTV2_FORMAT_UNKNOWN);
    inCard.GetVideoFormat (channelFormat, inChannel);
    outReceivedLTC.Set();  outReceivedVITC1.Set();  outReceivedVITC2.Set();  // Make invalid

    //  Any TC available?
    inCard.ReadRegister (gChToRP188DBBRegNum[inChannel], receivedAnyRP188, BIT(16), 16);
    if (!receivedAnyRP188)
        return false;

    //  Read the input filter, can be overridden by software any time (AutoCirculate initializes once)
    inCard.ReadRegister (gChToRP188DBBRegNum[inChannel], inputFilter, (ULWord)kRegMaskRP188SourceSelect, kRegShiftRP188Source);

    //  If the filter is not FF, only fill in the selected (if received)...
    switch (inputFilter)
    {
        case 0x0000:    //  User requested LTC only
            inCard.ReadRegister(gChToRP188DBBRegNum[inChannel], &receivedLTC, BIT(17), 17);
            if (receivedLTC)
                inCard.GetRP188Data (inChannel, outReceivedLTC);
            break;

        case 0x0001:    //  User requested VITC only
            inCard.ReadRegister (gChToRP188DBBRegNum[inChannel], receivedLTC, BIT(18), 18);
            if (!receivedLTC  &&  inChannel == NTV2_CHANNEL1)
                inCard.ReadRegister (kRegFS1ReferenceSelect, receivedLTC, BIT(9), 9);  // Reg 95
            if (receivedLTC)
            {
                inCard.GetRP188Data (inChannel, outReceivedLTC);
                outReceivedLTC.DBB |= BIT(18);    //  Set "LTC received" bit
            }
            inCard.ReadRegister (gChToRP188DBBRegNum[inChannel], receivedVITC1, BIT(17), 17);
            if (receivedVITC1)
            {
                outReceivedVITC1.DBB = inCard.ReadRegister (gChToRP188DBBRegNum[inChannel]);
                outReceivedVITC1.Low = inCard.ReadRegister (gChannelToRP188Bits031RegisterNum[inChannel]);
                outReceivedVITC1.High = inCard.ReadRegister (gChannelToRP188Bits3263RegisterNum[inChannel]);
            }
            break;

        default:    //  User requested whatever's there
            //  Check for LTC...
            inCard.ReadRegister (gChToRP188DBBRegNum[inChannel], receivedLTC, BIT(18), 18);
            if (!receivedLTC  &&  inChannel == NTV2_CHANNEL1)
                inCard.ReadRegister (kRegFS1ReferenceSelect, receivedLTC, BIT(9), 9);  // Reg 95
            if (receivedLTC)
            {
                inCard.GetRP188Data (inChannel, outReceivedLTC);
                outReceivedLTC.DBB |= BIT(18);    //  Set "LTC received" bit
            }

            //  Check for VITC1/VITC2...
            inCard.ReadRegister (gChToRP188DBBRegNum[inChannel], receivedVITC1, BIT(19), 19);
            inCard.ReadRegister (gChToRP188DBBRegNum[inChannel], receivedVITC2, BIT(17), 17);
            if (receivedVITC1  &&  receivedVITC2)
            {
                inCard.GetRP188Data (inChannel, outReceivedVITC1);
                inCard.GetRP188Data (inChannel, outReceivedVITC2);
            }
            else
            {
                if (receivedVITC1)
                    inCard.GetRP188Data (inChannel, outReceivedVITC1);
                if (receivedVITC2)
                {
                    if (NTV2_VIDEO_FORMAT_HAS_PROGRESSIVE_PICTURE(channelFormat))
                        inCard.GetRP188Data (inChannel, outReceivedVITC1);
                    else
                        inCard.GetRP188Data (inChannel, outReceivedVITC2);
                }
            }
    }  //  switch on inputFilter
    return true;
}  //  GetReceivedTCForChannel
@endcode



@subsection		anctimecodeoutput		Embedded SDI Timecode Output

When RP-188 output is enabled for an SDI output (by calling CNTV2Card::SetRP188Mode and passing it ::NTV2_RP188_OUTPUT),
whatever RP-188 data was written into the RP-188 registers is inserted into the HANC of the SDI output video after the next
output VBI on the appropriate line (even when “tall” or “taller” \ref vancframegeometries are in use):
-	SD NTSC 720×486 — lines 10 & 273
-	SD PAL 720×576 — lines 7 & 320
-	HD 1280×720 & 1920×1080 & up — line 10

There are two ways to transmit timecode:
-	When using \ref autocirculateplayout, generally, AutoCirculate automatically configures the RP-188 registers,
	and writes the appropriate registers at the proper time using the provided timecode value(s).
	-	Pass ::AUTOCIRCULATE_WITH_RP188 to CNTV2Card::AutoCirculateInitForOutput.
	-	Before calling CNTV2Card::AutoCirculateTransfer, call one of …
		-	AUTOCIRCULATE_TRANSFER::SetOutputTimeCode, …or…
		-	AUTOCIRCULATE_TRANSFER::SetOutputTimeCodes.
		-	If more than one SDI output is connected to the FrameStore/Channel being AutoCirculated…
			-	call AUTOCIRCULATE_TRANSFER::SetOutputTimeCode multiple times, for each desired SDI output’s timecode value, or…
			-	call AUTOCIRCULATE_TRANSFER::SetOutputTimeCodes once, passing it an ::NTV2TimeCodes map that contains the
				timecodes to be written for each desired SDI output.
-	When not using \ref aboutautocirculate, for a given SDI output connector, do the following:
	-	During setup…
		-	Call CNTV2Card::SetRP188Mode and pass it ::NTV2_RP188_OUTPUT;
		-	Call CNTV2Card::DisableRP188Bypass to force the SDI output embedder to utilize the RP-188 registers.
	-	For each outgoing frame, call CNTV2Card::SetRP188Data to specify the RP-188 timecode to embed in the next outgoing
		frame (for a given SDI output connector).

@note	Starting in SDK 15.0, when doing \ref autocirculateplayout with both ::AUTOCIRCULATE_WITH_RP188 and ::AUTOCIRCULATE_WITH_ANC
		on an IP device (see ::NTV2DeviceCanDoIP) that supports SMPTE 2110 (see ::NTV2DeviceCanDo2110), CNTV2Card::AutoCirculateTransfer
		will automatically add all channel-relevant timecodes found in the AUTOCIRCULATE_TRANSFER::acOutputTimeCodes buffer into
		the relevant RTP packets in the AUTOCIRCULATE_TRANSFER::acANCBuffer and/or AUTOCIRCULATE_TRANSFER::acANCField2Buffer
		(see \ref ancrtpformat), augmenting what was already placed there. If this is not desired, and you’d prefer to use your
		own timecode packets, then call CNTV2Card::AutoCirculateInitForOutput without specifying ::AUTOCIRCULATE_WITH_RP188,
		then add the timecode ::AJAAncillaryData packet(s) to the ::AJAAncillaryList before calling AJAAncillaryList::GetIPTransmitData
		(prior to calling AUTOCIRCULATE_TRANSFER::SetAncBuffers and CNTV2Card::AutoCirculateTransfer).


@subsection		ancanalogltcinput		Analog LTC Input

On AJA devices having one or more analog LTC inputs — or devices that can receive LTC from the Reference Input — there’s a pair
of registers for each LTC input that store the received timecode:  one for the high-order 32 bits, the other for the low-order
32 bits. Historically, the LTC input circuitry has relied on the prevailing input’s frame rate to know when to fetch and decode
the incoming analog timecode signal and latch the detected timecode values.

@note	On newer multi-format-capable devices (see ::NTV2DeviceCanDoMultiFormat), the incoming LTC frame rate must match a
		designated SDI input’s frame rate (see CNTV2Card::SetAnalogLTCInClockChannel).


There are two ways to input analog LTC:
-	Using \ref autocirculatecapture :
	-	AutoCirculate automatically reads the LTC registers at the proper time, and provides the captured
		timecode with each captured frame.
	-	Pass ::AUTOCIRCULATE_WITH_LTC to CNTV2Card::AutoCirculateInitForInput.
	-	After each successful call to CNTV2Card::AutoCirculateTransfer, look for the captured LTC returned
		from AUTOCIRCULATE_TRANSFER::GetInputTimeCodes …
		-	in the ::NTV2TimeCodes map — use ::NTV2_TCINDEX_LTC1 or ::NTV2_TCINDEX_LTC2 as the key;
		-	in the ::NTV2TimeCodeList vector — use ::NTV2_TCINDEX_LTC1 or ::NTV2_TCINDEX_LTC2 as the index.
-	Without \ref aboutautocirculate :
@code{.cpp}
	CNTV2Card device;
	// . . . 
	NTV2_ASSERT(device.IsOpen()  &&  "Device must be open");
	const NTV2DeviceID deviceID (device.GetDeviceID());
	bool               canReadAnalogLTC (false);
	bool		       isMultiFormatMode (false);
	UWord              whichLTCInput(0);
	NTV2Channel        whichSDIInputHasInputClock(NTV2_CHANNEL1);

	// Check device capability...
	if (::NTV2DeviceGetNumLTCInputs(deviceID)
		|| (::NTV2DeviceGetNumReferenceVideoInputs(deviceID) && ::NTV2DeviceCanDoLTCInOnRefPort(deviceID)))
			canReadAnalogLTC = true;

	if (::NTV2DeviceCanDoLTCInOnRefPort(deviceID))
		device.SetLTCInputEnable(true);
	if (::NTV2DeviceCanDoMultiFormat(deviceID))
		if (device.GetMultiFormatMode(isMultiFormatMode))
			if (isMultiFormatMode)
				device.SetAnalogLTCInClockChannel(whichLTCInput, whichSDIInputHasInputClock);

	// Process frames...
	while (::WaitForInputFieldID(NTV2_FIELD0, whichSDIInputHasInputClock))
	{
		NTV2_RP188	analogLTC;
		bool        analogLTCPresent (false);
		if (canReadAnalogLTC)
			device.GetLTCInputPresent(analogLTCPresent);  // Anything there?
		if (analogLTCPresent)
			device.ReadAnalogLTCInput(whichLTCInput, analogLTC);
		if (analogLTC.IsValid())
		{
			// Do something with the timecode data...
			std::cout << analogLTC << std::endl;
		}
	}  // for each frame
@endcode


@subsection		ancanalogltcoutput		Analog LTC Output

On AJA devices having one or more analog LTC outputs — there’s a pair of registers for each LTC output for placing
the timecode to be transmitted:  one for the high-order 32 bits, the other for the low-order 32 bits. 

LTC output can be driven “end-to-end” by its corresponding LTC input.

There are two ways to output analog LTC:
-	Using \ref autocirculateplayout :
	-	AutoCirculate automatically sets the LTC output register(s) at the proper time.
	-	Pass ::AUTOCIRCULATE_WITH_LTC to CNTV2Card::AutoCirculateInitForOutput.
	-	Before calling CNTV2Card::AutoCirculateTransfer, call one of …
		-	AUTOCIRCULATE_TRANSFER::SetOutputTimeCode … or …
		-	AUTOCIRCULATE_TRANSFER::SetOutputTimeCodes …
		-	…using ::NTV2_TCINDEX_LTC1 or ::NTV2_TCINDEX_LTC2 as the index (or key), as required.
-	Otherwise, without \ref aboutautocirculate :
	-	Call CNTV2Card::WriteAnalogLTCOutput. After the next output VBI, the given timecode will be sent
		out the specified LTC output connector.
-	Call ::NTV2DeviceGetNumLTCOutputs to discover the number of LTC outputs.

<hr size="50px">


@section		ancvpid		VPID

<b>Input</b>

On AJA devices with one or more SDI inputs (3G or faster), when a signal is present, the firmware automatically looks for and detects
VPID (Video Payload IDentifier) packets on link A (and link B, if present), and stores the extracted VPID data value(s) into separate
register(s), one per link.

There are two methods to read input VPID:
-	All devices:
	-	To detect if a VPID packet was present on an SDI input’s “A” link, call CNTV2Card::GetVPIDValidA.
	-	To detect if a VPID packet was present on an SDI input’s “B” link, call CNTV2Card::GetVPIDValidB.
	-	To get the extracted VPID payload data values, call CNTV2Card::ReadSDIInVPID.
-	Devices that have <b>Anc Extractor</b> firmware described in \ref anccapture (below) can capture the “raw” HANC VPID
	packet data … then decode it per SMPTE specifications.


<b>Output</b>

On AJA devices with one or more SDI outputs (3G or faster), there are two VPID output payload registers for each SDI output
(one for Link A, another for Link B). When the driver is running in ::NTV2EveryFrameTaskMode ::NTV2_STANDARD_TASKS (retail)
or ::NTV2_OEM_TASKS, it will automatically write the proper VPID payload value(s) into these registers when the output video
standard is set. The SDI output’s Anc embedder, upon seeing a valid VPID payload in the respective payload register, will
automatically insert a VPID packet in the outgoing SDI data stream.
-	To read the output VPID payload value(s) that are currently being used, call CNTV2Card::GetSDIOutVPID.
-	Call CNTV2Card::SetSDIOutVPID to set the output VPID payload value(s) to be transmitted — but be forewarned:
	-	The calling application will “fight” with the driver as to which values will actually get transmitted.
	-	To safely override the default output VPID payload values, …
		-	Write a non-zero value to the ::kVRegDisableAutoVPID virtual register (using CNTV2Card::WriteRegister)
			once when your program starts.
		-	Call CNTV2Card::SetSDIOutVPID to set the outgoing VPID payload value as needed.
		-	Don’t forget to set ::kVRegDisableAutoVPID back to zero when your program exits.

<hr size="50px">



@section	anccapture	Custom Anc Packet Capture

There are two ways to capture any/all Ancillary data packets:
-	<b>Use Anc Extractor firmware:</b>  <i>(Preferred)</i>
	-	Available on most devices — check ::NTV2DeviceCanDoCustomAnc.
	-	Ancillary data is automatically extracted and placed into a separate area of the device frame buffer.
	-	With \ref aboutautocirculate :
		-	SDK & driver version 12.3 or later required.
		-	Call CNTV2Card::AutoCirculateInitForInput with the ::AUTOCIRCULATE_WITH_ANC option.
		-	Call AUTOCIRCULATE_TRANSFER::SetAncBuffers to specify the destination host Anc buffer(s).
		-	After CNTV2Card::AutoCirculateTransfer returns, parse the contents of the host Anc buffer(s).
			-	Manually parse the data — see \ref ancgumpformat (below).
			-	Or use the \ref ajaanc — call AJAAncillaryList::SetFromDeviceAncBuffers to retrieve the ::AJAAncillaryData packets.
			-	<b>NOTE:</b> For SMPTE-2110 IP devices, CNTV2Card::AutoCirculateTransfer will have automatically converted the
				received host ancillary data from  \ref ancrtpformat into \ref ancgumpformat (SDK version 15.2 or later required).
	-	Without \ref aboutautocirculate :
		-	SDK 15.0 or later required.
		-	See \ref ntv2llburn for example of how to use CNTV2Card::AncExtractInit, CNTV2Card::AncExtractSetEnable,
			CNTV2Card::AncExtractSetWriteParams, etc.
		-	After CNTV2Card::DMAReadAnc returns, parse the contents of the host Anc buffer(s).
			-	Manually — see \ref ancgumpformat (below).
			-	Or use the \ref ajaanc — call AJAAncillaryList::SetFromDeviceAncBuffers to retrieve the ::AJAAncillaryData packets.
			-	<b>NOTE:</b> For SMPTE-2110 IP devices, CNTV2Card::DMAReadAnc will have automatically converted the received
				host ancillary data from  \ref ancrtpformat into \ref ancgumpformat (SDK version 15.2 or later required).
	-	Each Anc Extractor is capable of filtering certain types of ancillary data packets:
		-	Upon driver startup, all Anc Extractors are configured to exclude SMPTE 299 HANC Audio and Audio Control packets.
			These packets will not appear in the ancillary data buffer(s).
		-	Call CNTV2Card::AncExtractGetFilterDIDs to discover which packet DIDs are currently being excluded.
		-	Call CNTV2Card::AncExtractSetFilterDIDs to change which packet DIDs will be excluded.
		-	Use the ::NTV2DIDSet returned from CNTV2Card::AncExtractGetDefaultDIDs to restore the default packet exclusion list.
	-	The default maximum per-field ancillary data buffer capacity is 8K by default, or 16K per-frame, including overhead.
		Please <a href="https://sdksupport.aja.com/index.php?/Tickets/Submit">submit a Ticket</a> if you need to change this.
-	<b>Use VANC frame geometry</b>  <i>(for older AJA devices)</i>
	-	4K/UHD or larger rasters (i.e. ::NTV2FrameGeometry ≥ ::NTV2_FG_4x1920x1080) aren’t supported, and likely never will be.
	-	Only ::NTV2_FBF_10BIT_YCBCR and ::NTV2_FBF_8BIT_YCBCR buffer formats are officially supported. Others may work,
		but are untested.
	-	Signal paths involving CSCs/LUTs between the SDI input and the Frame Store may corrupt the VANC data.
	-	HANC is (obviously) not available in the frame buffer.
	-	Call CNTV2Card::SetVANCMode to enable the “tall” or “taller” frame geometry.
	-	See \ref vancframegeometries (below) for details on the locations of the SMPTE VANC lines in the frame buffer.
	-	After the frame has been transferred to the host, to obtain the ancillary data:
		-	Parse the VANC lines in the host frame buffer manually, or…
		-	Use AJAAncillaryList::SetFromVANCData to obtain a list of ::AJAAncillaryData packets found in the frame buffer.

<b>TIP:</b> The \ref usingntv2watcher tool’s \ref inspectoranc is useful for diagnosing issues with ancillary data capture.


@section	ancplayout	Custom Anc Packet Playout

There are two ways to play out custom Ancillary data packets:
-	<b>Use Anc Inserter firmware:</b>  <i>(Preferred)</i>
	-	Available on most devices — check ::NTV2DeviceCanDoCustomAnc.
	-	Ancillary data packets are automatically inserted into the outgoing video stream when they’ve been properly formatted
		and placed into a separate area of the device frame buffer.
	-	Cannot output HANC (sorry).
	-	With \ref aboutautocirculate :
		-	SDK & driver version 12.3 or later required.
		-	Call CNTV2Card::AutoCirculateInitForOutput with the ::AUTOCIRCULATE_WITH_ANC option.
		-	Call AUTOCIRCULATE_TRANSFER::SetAncBuffers to specify the source host Anc buffer(s).
		-	Before calling CNTV2Card::AutoCirculateTransfer, set the contents of the host Anc buffer(s)…
			-	Manually write the data — see \ref ancgumpformat (below).
			-	Or use the \ref ajaanc — call AJAAncillaryList::GetTransmitData.
			-	For SMPTE-2110 IP devices, CNTV2Card::AutoCirculateTransfer will automatically convert the data from
				\ref ancgumpformat into \ref ancrtpformat (SDK version 15.2 or later required).
	-	Without \ref aboutautocirculate :
		-	SDK 15.0 or later required.
		-	See \ref ntv2llburn for example of how to use CNTV2Card::AncInsertInit, CNTV2Card::AncInsertSetEnable,
			CNTV2Card::AncInsertSetReadParams, etc.
		-	Before calling CNTV2Card::DMAWriteAnc, set the contents of the host Anc buffer(s)…
			-	Manually write the data — see \ref ancgumpformat (below).
			-	Or use the \ref ajaanc to put together an ::AJAAncillaryList of packets to send — then call
				AJAAncillaryList::GetTransmitData.
			-	For SMPTE-2110 IP devices, CNTV2Card::DMAWriteAnc will automatically convert the data from
				\ref ancgumpformat into \ref ancrtpformat (SDK version 15.2 or later required) immediately prior
				to the actual transfer.
	-	On SDI devices and SMPTE 2022 firmware on IP devices, the parity bits for outgoing 10-bit UDWs are automatically
		recalculated by the Anc inserter, after reading the 8-bit UDWs out of the Anc Buffer, while embedding the packet
		data into the outgoing SDI data stream.
	-	Default per-field ancillary data buffer capacity is 8K by default, or 16K per-frame, including overhead.
		Please <a href="https://sdksupport.aja.com/index.php?/Tickets/Submit">submit a Ticket</a> if you need to change this.
-	<b>Use VANC frame geometry</b>  <i>(for older AJA devices)</i>
	-	4K/UHD or larger rasters (i.e. ::NTV2FrameGeometry ≥ ::NTV2_FG_4x1920x1080) aren’t supported, and likely never will be.
	-	Only ::NTV2_FBF_10BIT_YCBCR or ::NTV2_FBF_8BIT_YCBCR buffer formats are officially supported. Others may work,
		but are untested.
	-	Signal paths involving CSCs/LUTs between the Frame Store and the SDI output may corrupt the VANC data.
	-	HANC obviously cannot be supported.
	-	Call CNTV2Card::SetVANCMode to enable the “tall” or “taller” frame geometry.
	-	See \ref vancframegeometries (below) for details on the locations of the SMPTE VANC lines in the frame buffer.
	-	Before transferring the frame to the device, set the contents of the VANC line(s)…
		-	If desired, use the \ref ajaanc — call AJAAncillaryList::GetVANCTransmitData.
		-	<b>CAUTION:</b> The device will transmit whatever Y/Cb/Cr values are in the VANC region of the buffer unfiltered,
			<i>including illegal values</i>, which can cause sync issues in downstream equipment. Be sure all values stored
			in the VANC lines are legal SMPTE.

@note	Because the outgoing line number can be specified when using the <b>Anc Inserter</b>, it's possible to
		overrun a line. Be certain that the data packets to be inserted on a given line will fit for the output
		video standard.

<b>TIP:</b> The \ref usingntv2watcher tool’s \ref inspectoranc is useful for diagnosing issues with ancillary data playout.

<hr size="50px">



@section	ancgumpformat	SDI Anc Buffer Data Format

This is the default format in the host ancillary data buffers. The data bytes in the ancillary data buffer consist of one or more packets having the following format:

@image	html	sdi_anc_pkt_fmt.png

@note	While the first byte of each packet is set to \c 0xFF, this is not a protected value, and can legally occur within
		packet data. Software parsers must use the packet Data Count (<b>DC</b>) value to determine the length of each packet.

For <b>Capture</b>:
-	Clients can parse the data themselves, using the above specification.
-	AJAAncillaryList::SetFromDeviceAncBuffers can be called to transform the buffer contents into an ::AJAAncillaryList
	containing one ::AJAAncillaryData instance per packet.

For <b>Playout</b>:
-	Clients can write the data themselves per the above specification.
-	AJAAncillaryList::GetTransmitData can be called to fill your Anc playout buffers from an ::AJAAncillaryList.
	-	If using \ref aboutautocirculate , these buffers can be transferred to the AJA device by first calling
		AUTOCIRCULATE_TRANSFER::SetAncBuffers , then calling CNTV2Card::AutoCirculateTransfer.
	-	If not using AutoCirculate, the buffers can be transferred to the AJA device using CNTV2Card::DMAWriteAnc.

<hr size="50px">



@section	ancrtpformat	RTP Anc Buffer Data Format

The data in the ancillary data buffer, except where noted (below), matches the RTP specification documented
in <a href="https://tools.ietf.org/html/draft-ietf-payload-rtp-ancillary-14" target="_blank">SMPTE ST 291-1</a>:

@image	html	fbf-rtp.png

For <b>Capture</b>:
-	Clients can parse the data themselves, using the above specification.
-	AJAAncillaryList::SetFromDeviceAncBuffers can be called to transform the buffer contents into an ::AJAAncillaryList
	containing one ::AJAAncillaryData instance per packet.

For <b>Playout</b>:
-	Clients can write the data themselves per the RTP specification.
	-	Clients that generate the Anc data buffer contents themselves must set the <b>Sequence Number</b> field in the first
		longword of the RTP packet header to the total RTP packet bytecount, since AJA IP devices running 2110 firmware
		(\ref konaip and \ref ioip) expect it there.
-	AJAAncillaryList::GetTransmitData can be called to fill the host Anc data buffers from an ::AJAAncillaryList.
	-	If using \ref aboutautocirculate , these buffers can be transferred to the AJA device by first calling
		AUTOCIRCULATE_TRANSFER::SetAncBuffers , then calling CNTV2Card::AutoCirculateTransfer.
	-	If not using AutoCirculate, the buffers can be transferred to the AJA device using CNTV2Card::DMAWriteAnc.
	-	Either way, the \ref ancgumpformat will be automatically converted to \ref ancrtpformat expected by the device
		before the DMA transfer.

<hr size="50px">



@section	vancframegeometries		VANC Frame Geometries

The older way of extracting or inserting ancillary data (VANC only) employs alternate frame geometries that have additional lines
at the top of the video frame buffer. To enable VANC capture/playout, call CNTV2Card::SetEnableVANCData or CNTV2Card::SetVANCMode.

For historical reasons, there are both "tall" and "taller" geometries. The taller ones grab some extra lines that used to be
omitted, but which turned out to contain useful information after all.

Note that using a VANC-enabled frame geometry will increase the size, in bytes, of the requisite host frame buffer versus the
equivalent non-VANC geometry. Use CNTV2Card::GetFrameBufferSize function to determine how large the host frame buffer should be.

There are some considerations on which frame buffer formats should be used for capture or playout with VANC:
-	::NTV2_FBF_8BIT_YCBCR — This is the easiest format to use, but there’s a catch.
	Ordinarily, the least-significant 2 bits of 10-bit YCbCr pixel data are discarded when filling the 8-bit pixel data words
	in the frame buffer (in capture mode). This is fatal to ancillary data in the VANC lines, because per SMPTE ST-291,
	the <b><i>most</i></b>-significant 2 bits of the 10-bit data word can be dropped/ignored, <b><i>not</i></b> the
	least-significant 2 bits. Fortunately, the AJA device firmware can be told to store the LS 8 bits of each 10-bit word
	in the VANC area during capture (or left-shift by 2 bits during playout) by calling CNTV2Card::SetVANCShiftMode.
	Thus, when a frame is captured using ::NTV2_VANCDATA_8BITSHIFT_ENABLE mode, VANC lines can be easily parsed into Ancillary packets.
	@note	::NTV2_VANCDATA_8BITSHIFT_ENABLE mode is not implemented for SD 525i/625i video formats.
			This is due to historical reasons, since back when HD was introduced, SD typically carried ancillary data
			in other ways (e.g. line 21 for captions).
-	::NTV2_FBF_10BIT_YCBCR — With 10-bit YCbCr, ancillary data packets can be read/written from/to the VANC lines,
	but the scanning process is more difficult, due to the packing of 10-bit words in the frame buffer.
-	Dual-link RGB video to/from YCbCr frame buffers generally won't work because the VANC data gets corrupted by
	the color-space converters. However, dual-link RGB video to/from RGB frame buffers (directly from/to the SDI spigots)
	will work.

@note	Mixer/Keyer widgets on newer devices (generally, those that support ::NTV2DeviceCanDoCustomAnc) will pass VANC.
		Call CNTV2Card::GetMixerVancOutputFromForeground to determine if the Mixer is configured to pass foreground or background VANC.
		Call CNTV2Card::SetMixerVancOutputFromForeground to change the setting.

To <b>Capture</b> custom ancillary data packets using VANC lines in the frame buffer:
-	AJAAncillaryList::SetFromVANCData (SDKs 14.1 and later) can be called to obtain an ::AJAAncillaryList
	containing one ::AJAAncillaryData instance per packet.
-	The ::CNTV2SMPTEAncData class in the \ref ajacc has some functions (e.g., CNTV2SMPTEAncData::FindAnc) to help with the parsing,
	though SD video formats aren’t supported (again, due to historical reasons).
-	Write your own functions to parse the frame buffer VANC lines.

To <b>Playout</b> custom ancillary data packets using VANC lines in the frame buffer:
-	Given an ::AJAAncillaryList of packets, call AJAAncillaryList::GetVANCTransmitData (SDKs 14.1 and later) to write the packets
	into a frame buffer’s VANC region.
-	The ::CNTV2SMPTEAncData class in the \ref ajacc has some functions (e.g., CNTV2SMPTEAncData::InsertAnc) to help with this,
	though SD video formats aren’t supported (again, due to historical reasons).
-	Write your own functions to write the frame buffer VANC lines.


The spreadsheets that follow show, in detail for each video format, which lines contain VANC, and which ones contain video data.

@subsection	sd525i			SD 525i

@image	html	vvi-525i-75.png

@subsection	sd525p60		SD 525p60

@image	html	vvi-525p-75.png

@subsection	sd625i			SD 625i

@image	html	vvi-625i-75.png

@subsection	sd625p			SD 625p

@image	html	vvi-625p-75.png

@subsection	hd720p			HD 720p

@image	html	vvi-720p-75.png

@subsection	hd1080p			HD 1080p

@image	html	vvi-1080p-75.png

@subsection	hd1080i			HD 1080i/psF

@image	html	vvi-1080i-75.png

@subsection	hd1080pdl		HD 1080p Dual-Link

@image	html	vvi-1080pduallink-75.png

@subsection	hd1035i60		HD 1035i60 (SMPTE 240)

@image	html	vvi-1035i-75.png

@subsection	hd2k1080p		2K: 1080p

@image	html	vvi-2k1080p-75.png

@subsection	hd2k1556psf15	2K: 1556psF @ 15fps

@image	html	vvi-2k1556psf15-75.png

@subsection	hd2k1556psf18	2K: 1556psF @ 18fps

@image	html	vvi-2k1556psf18-75.png

**/
