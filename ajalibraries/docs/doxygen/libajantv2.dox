/**
	@page	ajantv2		“libajantv2” Class Library

	This library contains the principal classes and data types that interface with the NTV2 device driver,
	plus a number of utility classes that deal with NTV2-specific data formats.

	Most NTV2 functions and class methods return a <b>bool</b> value of <b>true</b> for “success” and <b>false</b> for “failure”.
	NTV2 functions and classes do not intentionally or explicitly throw exceptions.
	Under unusual and extreme conditions (e.g. memory exhaustion), it's possible for an exception to be thrown (e.g. std::bad_alloc).


    @par		Principal Classes

	-	::CNTV2DeviceScanner — enumerates attached devices
	-	::CNTV2Card — queries and/or controls a device
	-	::CNTV2SignalRouter — a collection of signal routes that can be applied to a device
	-	::NTV2FormatDescriptor — describes an NTV2 raster image
	-	::NTV2_POINTER — describes memory buffers and perform operations on them
	-	::AUTOCIRCULATE_TRANSFER — Provides information used in CNTV2Card::AutoCirculateTransfer calls

	@note	Avoid deriving subclasses from AJA-provided classes.
			AJA recommends using aggregation techniques to incorporate NTV2 functionality into your own classes.



	@par		Device Scanner Class

	The ::CNTV2DeviceScanner class is used to enumerate or find available devices.

	@par	Example: Discovering all attached devices
	@code{.cpp}
		CNTV2Card   device;
		ULWord		ndx(0);
		while (CNTV2DeviceScanner::GetDeviceAtIndex (ndx, device))
		{
			//	The device instance is guaranteed to be open and valid if GetDeviceAtIndex returns true
			std::cout << ndx << ": " << device.GetDisplayName() << std::endl;
			ndx++;
		}
	@endcode



	@par		CNTV2Card Class

	The ::CNTV2Card class is used to interrogate and control an NTV2 device.
	Normally an instance of this class is obtained from one of the ::CNTV2DeviceScanner class methods.
	For multiple, concurrent ingest or playout threads, it's recommended to use separate CNTV2Card instances for better performance.

	@par	Example: Read FrameStore 1 Control Register
	@code{.cpp}
		CNTV2Card device;
		if (CNTV2DeviceScanner::GetDeviceAtIndex (0, device))
		{
			ULWord value(0);
			device.ReadRegister(1, value);
		}
	@endcode



	@par		Device Features API

	The “NTV2Device…” functions describe AJA NTV2 device capabilities.
	All of the functions accept an ::NTV2DeviceID parameter that identifies the AJA device model of interest.

	@note	A device need not be installed in or attached to the host to use these functions.

	@par	‘CanDo’ Functions

	These functions have names starting with “NTV2DeviceCanDo…” and return a \c bool value that answers Yes or No for a particular device capability.
	Most of them accept a single ::NTV2DeviceID parameter, like ::NTV2DeviceCanDoAnalogAudio, which answers true if the device is capable of working
	with analog audio.  A smaller set of functions accept two parameters:  the ::NTV2DeviceID parameter, and a second enumeration parameter, for determining
	if a device is capable of working with a particular video format (e.g., ::NTV2DeviceCanDoVideoFormat) or frame buffer format (::NTV2DeviceCanDoFrameBufferFormat), etc.

	For example, to find out which Thunderbolt-connected devices support ::NTV2_FBF_10BIT_RGB, you can code the following:

	@code{.cpp}
		const NTV2DeviceIDSet  supportedDeviceIDs (::NTV2GetSupportedDevices());
		NTV2DeviceIDSet        deviceIDsWithThunderboltAndRGB10;
		for (NTV2DeviceIDSetConstIter it(supportedDeviceIDs.begin());  it != supportedDeviceIDs.end();  ++it)
		{
			if (::NTV2DeviceCanDoThunderbolt(*it)  &&  ::NTV2DeviceCanDoFrameBufferFormat(*it, NTV2_FBF_10BIT_RGB))
				deviceIDsWithThunderboltAndRGB10.push_back (*it);
		}
	@endcode

	@par	‘Has’ Functions

	These functions are similar to the “Can Do” functions. They also return a \c bool value that answers Yes or No for a particular device capability.
	For example, you may want to know if a device has bi-directional SDI connectors:

	@code{.cpp}
		CNTV2Card   theDevice;
		NTV2Channel outputChannel(NTV2_CHANNEL2);
		. . .
		if (::NTV2DeviceHasBiDirectionalSDI(theDevice.GetDeviceID())
			theDevice.SetSDITransmitEnable(outputChannel, true);
	@endcode

	@par	‘GetNum’ Functions

	These functions return a count of a particular device feature. For example, to find out which devices have at least one HDMI output:

	@code{.cpp}
		const NTV2DeviceIDSet  supportedDeviceIDs(::NTV2GetSupportedDevices());
		NTV2DeviceIDSet        deviceIDsWithHDMIOut;
		for (NTV2DeviceIDSetConstIter it(supportedDeviceIDs.begin());  it != supportedDeviceIDs.end();  ++it)
		{
			if (::NTV2DeviceGetNumHDMIVideoOutputs(*it) > 0)
				deviceIDsWithHDMIOut.push_back(*it);
		}
	@endcode
**/
