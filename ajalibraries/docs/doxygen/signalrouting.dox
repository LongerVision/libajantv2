/**
	@page	ntv2signalrouting		Widgets and Signal Routing

	NTV2 device FPGA firmware implements several types of “widgets“ for receiving, processing and transmitting video data.
	These can be classified as follows:
	-	\ref widget_inputs
		-	\ref widget_sdiin
		-	\ref widget_hdmiin
		-	\ref widget_anlgin
	-	\ref widget_outputs
		-	\ref widget_sdiout
		-	\ref widget_hdmiout
		-	\ref widget_anlgout
	-	\ref widget_processing
		-	\ref widget_framestore
		-	\ref widget_csc
		-	Color Look-Up-Tables (LUTs)
		-	\ref widget_mixkey
		-	Dual-Link (DL) converters (input & output)
		-	Two-sample-interleave (Tsi) muxers/demuxers
		-	4K Down-converters
		-	DVC Pro converters
		-	Universal Frequency Converters (UFCs)
	-	\ref recipes_capture
	-	\ref recipes_playout
	-	\ref recipes_endtoend

	Most widgets typically have one or more registers associated with them for reporting status, or to control their operation.
	Rather than calling CNTV2Card::ReadRegister or CNTV2Card::WriteRegister, client applications should use the
	appropriate widget-related API calls in the ::CNTV2Card class to inquire about and/or control the widget of interest.

	All widgets have a unique identifier in software expressed by the ::NTV2WidgetID enumeration.
	To determine if a device implements a particular widget, call ::NTV2DeviceCanDoWidget.

	Video data paths between widgets are implemented using <b>crosspoints</b> in firmware.
	-	Widget <b>inputs</b> are identified by ::NTV2InputCrosspointID.
	-	Widget <b>outputs</b> are identified by ::NTV2OutputCrosspointID.
	-	<b>Input Widgets</b> only have <b>output</b> crosspoint connections.
	-	<b>Output Widgets</b> only have <b>input</b> crosspoint connections.
	-	<b>Processing Widgets</b> have both <b>input</b> and <b>output</b> crosspoint connections.

	The ::CNTV2SignalRouter class has static methods that are useful for inquiring about device widgets and their input and output crosspoints:
	-	CNTV2SignalRouter::GetWidgetIDs answers with an ::NTV2WidgetIDSet of all widgets supported by a given device.
	-	CNTV2SignalRouter::GetWidgetForInput reports the widget (::NTV2WidgetID) that’s associated with a given ::NTV2InputCrosspointID.
	-	CNTV2SignalRouter::GetWidgetForOutput reports the widget (::NTV2WidgetID) associated with a given ::NTV2OutputCrosspointID.
	-	CNTV2SignalRouter::GetWidgetInputs reports all input crosspoints for a given widget.
	-	CNTV2SignalRouter::GetWidgetOutputs reports all output crosspoints for a given widget.

	A set of “crosspoint select” registers (e.g., ::kRegXptSelectGroup1, ::kRegXptSelectGroup2, etc.) determine which widget output
	will feed (source) each widget’s input.

	@note	A widget’s output can source multiple widgets’ inputs,
			while a widget’s input can only be sourced by one other widget’s output.
			In other words, widget outputs are one-to-many, while widget inputs are one-to-one.

	@note	Due to FPGA size limitations, only a small fraction of the possible widget interconnection routes are implemented.

	@note	Widget inputs that are left open — i.e., disconnected — i.e. aren’t connected to any other widget’s output — default
			to the ::NTV2_XptBlack output crosspoint.

	The CNTV2Card::Connect call is used to make and/or break these output-to-input crosspoint connections.
	The CNTV2Card::ClearRouting function breaks <i>all</i> crosspoint connections.

	Historically, there was no programmatic way in NTV2 to determine at runtime if a device implemented a specific connection path.
	Starting in SDK 14.0, AJA finally implemented a program that inspects the FPGA source code to compile a static “implemented routes”
	table that’s queried by the CNTV2Card::CanConnect function. These tables are correct and complete for firmware versions used
	at the time of the SDK release. However, subsequent firmware updates may add or remove interconnect routes that would not be
	reflected in the tables used by the SDK. We hope to improve this process going forward.

	The NTV2 SDK provides two tools that graphically show the available device widgets and the signal routing between them.
	-	\ref usingcables — An ancient, but still functional graphical utility that allows you to inspect and interactively change
		widget configuration and signal routing paths between widgets.
	-	The \ref inspectorroute in \ref usingntv2watcher — This will eventually incorporate the functionality of \ref usingcables .



	<hr size="50px">
	@section	widget_inputs	Input Widgets

	These widgets only have output crosspoints that provide signal sources for signal-processing or output widgets.

	@note	An input widget’s output can be used to source multiple output and signal-processing widgets’ inputs.


	@subsection	widget_sdiin	SDI Input

	An SDI Input widget represents a physical SDI input connector.
	-	There is one of these widgets for each input SDI connector (e.g. ::NTV2_WgtSDIIn1, ::NTV2_WgtSDIIn2, …).
	-	For devices that have bi-directional SDI connectors (see ::NTV2DeviceHasBiDirectionalSDI),
		there will be one of these widgets for each <i>potential</i> SDI input connector.
	-	Older devices that only support 1.5Gbps SDI use “non-3G” SDI input widgets — ::NTV2_WgtSDIIn1, ::NTV2_WgtSDIIn2, etc.
	-	Devices that support 3Gbps SDI have “3G” SDI input widgets — ::NTV2_Wgt3GSDIIn1, ::NTV2_Wgt3GSDIIn2, etc.
	-	Devices that support 6Gbps or higher SDI have “12G” SDI input widgets — ::NTV2_Wgt12GSDIIn1, ::NTV2_Wgt12GSDIIn2, etc.
	-	3Gbps SDI inputs have two output crosspoints — one for DS1, another for DS2, the latter used in dual-link applications.
		Note that the \ref konalhi, AJA’s first 3Gbps SDI board, used ::NTV2_WgtSDIIn2 for DS1 and ::NTV2_WgtSDIIn2 for DS2.
	-	There are two ways to obtain an SDI input’s ::NTV2OutputCrosspointID …
		-	Call ::GetSDIInputOutputXptFromChannel …
			-	Specify the SDI input connector by ::NTV2Channel (e.g., use ::NTV2_CHANNEL3 for SDI In 3).
			-	By default, it returns data stream 1’s crosspoint.
				To obtain Data Stream 2’s crosspoint, specify \c true for \c inIsDS2.
		-	Or call ::GetInputSourceOutputXpt …
			-	Specify the SDI input by passing it ::NTV2_INPUTSOURCE_SDI1, ::NTV2_INPUTSOURCE_SDI2, …etc.
			-	By default, it returns Data Stream 1’s crosspoint.
				For Data Stream 2’s crosspoint, specify \c true for \c inIsSDI_DS2.


	@subsection	widget_hdmiin	HDMI Input

	An HDMI Input widget represents a physical HDMI input connector.
	-	There is one of these widgets for each input HDMI connector.
	-	Older devices with our 1st-generation HDMI chip use ::NTV2_WgtHDMIIn1.
	-	Devices that support our 2nd-generation HDMI chip use ::NTV2_WgtHDMIIn1v2.
	-	Devices that support our 3rd-generation HDMI chip use ::NTV2_WgtHDMIIn1v3.
	-	Devices that support our 4th-generation HDMI chip use ::NTV2_WgtHDMIIn1v4, etc. Each of these have separate YCbCr and RGB output crosspoints.
	-	To obtain its ::NTV2OutputCrosspointID …
		-	Call ::GetInputSourceOutputXpt …
			-	Specify which HDMI input by passing it ::NTV2_INPUTSOURCE_HDMI1, ::NTV2_INPUTSOURCE_HDMI2, …etc.
			-	For 4K/UHD applications, specify the appropriate quadrant number 0, 1, 2 or 3 in the \c inHDMI_Quadrant
				parameter.
			-	For the RGB output crosspoint instead of the default YUV one (4th-generation HDMI only), pass \c true
				for the \c inIsHDMI_RGB parameter.


	@subsection	widget_anlgin	Analog Video Input

	An Analog Video Input widget represents a physical analog video input connector (typically RCA connectors labeled Y/G/CVBS,
	Pb/B/Y and Pr/R/C RCA connectors).
	-	There is one of these widgets for devices that support analog video input — ::NTV2_WgtAnalogIn1.
	-	To obtain its ::NTV2OutputCrosspointID …
		-	Either use ::NTV2_XptAnalogIn directly;
		-	Or call ::GetInputSourceOutputXpt with ::NTV2_INPUTSOURCE_ANALOG1.



	<hr size="50px">
	@section	widget_outputs	Output Widgets

	These widgets only have input crosspoints that accept signals from signal-processing or input widgets.

	@note	An output widget’s input can only be sourced from a single input or signal-processing widget’s output.


	@subsection	widget_sdiout	SDI Output

	An SDI Output widget represents one of the device’s physical SDI output connectors.
	-	There is one of these widgets for each output SDI connector (e.g. ::NTV2_WgtSDIOut1, ::NTV2_WgtSDIOut2, …).
	-	For devices that have bi-directional SDI connectors (see ::NTV2DeviceHasBiDirectionalSDI),
		there will be one of these widgets for each <i>potential</i> SDI output connector.
	-	Older devices that only support 1.5Gbps SDI use “non-3G” SDI output widgets — ::NTV2_WgtSDIOut1, ::NTV2_WgtSDIOut2, etc.
	-	Devices that support 3Gbps SDI have “3G” SDI output widgets — ::NTV2_Wgt3GSDIOut1, ::NTV2_Wgt3GSDIOut2, etc.
	-	Devices that support 6Gbps or higher SDI have “12G” SDI output widgets — ::NTV2_Wgt12GSDIOut1, ::NTV2_Wgt12GSDIOut2, etc.
	-	3Gbps SDI outputs have two input crosspoints — one for DS1, another for DS2, the latter used in dual-link applications.
	-	There are two ways to obtain an SDI output’s ::NTV2InputCrosspointID …
		-	Call ::GetSDIOutputInputXpt …
			-	Specify the SDI output connector by ::NTV2Channel (e.g. use ::NTV2_CHANNEL3 for SDI Out 3);
			-	For dual-link applications, pass \c true for \c inIsDS2 for the 2nd dual-link stream.
		-	Or call ::GetOutputDestInputXpt …
			-	Specify the SDI output connector using ::NTV2_OUTPUTDESTINATION_SDI1, ::NTV2_OUTPUTDESTINATION_SDI2, … etc.
			-	For dual-link applications, pass \c true for \c inIsSDI_DS2 for the 2nd dual-link stream.


	@subsection	widget_hdmiout	HDMI Output

	An HDMI Output widget represents a physical HDMI output connector.
	-	There is one of these widgets for the output HDMI connector — ::NTV2_WgtHDMIOut1.
	-	Older devices use ::NTV2_WgtHDMIOut1.
	-	Devices that support our 2nd-generation HDMI chip use ::NTV2_WgtHDMIOut1v2.
	-	Devices that support our 3rd-generation HDMI chip use ::NTV2_WgtHDMIOut1v3.
	-	Devices that support our 4th-generation HDMI chip use ::NTV2_WgtHDMIOut1v4.
	-	To obtain its output crosspoint(s)…
		-	Call ::GetOutputDestInputXpt, passing it ::NTV2_OUTPUTDESTINATION_HDMI.
			For 4K/UHD quadrants, you can specify a quadrant number (0, 1, 2 or 3).


	@subsection	widget_anlgout	Analog Video Output

	An Analog Video Output widget represents a physical analog video output connector (typically RCA connectors labeled Y/G/CVBS,
	Pb/B/Y and Pr/R/C RCA connectors).
	-	There is one of these widgets for devices that support analog video output — ::NTV2_WgtAnalogOut1.
	-	To obtain its ::NTV2InputCrosspointID …
		-	Use ::NTV2_XptAnalogOutInput
		-	Call ::GetOutputDestInputXpt with ::NTV2_OUTPUTDESTINATION_ANALOG.


	<hr size="50px">
	@section	widget_processing	Signal-Processing Widgets

	These widgets have both input and output crosspoints. They accept and consume a signal from another source, and perform some
	kind of processing on it, and send it on to another widget for consumption downstream.

	@note	A signal-processing widget’s output can source multiple widgets’ inputs,
			while each of its inputs can only be sourced by one other widget’s output.


	@subsection	widget_framestore	Frame Store

	A <b>Frame Store</b> widget represents the firmware entity responsible for writing or reading video frames to or from device SDRAM.
	-	::NTV2DeviceGetNumFrameStores will report the number of Frame Store widgets that are available on a given device.
	-	Frame Store widgets are identified by ::NTV2_WgtFrameBuffer1, ::NTV2_WgtFrameBuffer2, etc.
	-	In <b>Capture Mode</b>…
		-	The normal (“Level A”) input crosspoint is available and should be used for most applications.
		-	There is a “Level B” input crosspoint that is available for dual-link applications.
		-	Call ::GetFrameBufferInputXptFromChannel to obtain a Frame Store’s ::NTV2InputCrosspointID …
			-	Specify the Frame Store of interest by ::NTV2Channel (i.e., ::NTV2_CHANNEL1, ::NTV2_CHANNEL2, …etc.).
			-	By default, the function returns the normal “Level A” input crosspoint.
				Specify \c true for \c inIsBInput for the “Level B” crosspoint.
	-	In <b>Playout Mode</b>…
		-	If the Frame Store is configured for SD, HD, or 4K/UHD Quads/Squares (i.e. non-Tsi) mode:
			-	Use the normal <b>YUV</b> output crosspoint when the FrameStore is using a YCbCr ::NTV2FrameBufferFormat.
			-	Use the <b>RGB</b> output crosspoint when the FrameStore is using an RGB ::NTV2FrameBufferFormat.
		-	If the Frame Store is configured for 4K/UHD Tsi (SMPTE 425 two-sample-interleave) mode:
			-	Use the “425” YUV output crosspoint when the FrameStore is using a YCbCr ::NTV2FrameBufferFormat (see ::NTV2_FBF_IS_YCBCR macro).
			-	Use the “425” RGB output crosspoint when the FrameStore is using an RGB ::NTV2FrameBufferFormat (see ::NTV2_IS_FBF_RGB macro).
		-	Call ::GetFrameBufferOutputXptFromChannel to obtain a Frame Store’s ::NTV2OutputCrosspointID …
			-	Specify the Frame Store of interest by ::NTV2Channel (i.e., ::NTV2_CHANNEL1, ::NTV2_CHANNEL2, …etc.).
			-	By default, the function returns the YUV output crosspoint. If the Frame Store’s ::NTV2FrameBufferFormat
				is an RGB format, pass \c true for \c inIsRGB to obtain the RGB crosspoint.
			-	By default, the function will return a normal, non-SMPTE-425 (non-Tsi) output crosspoint.
				If the Frame Store is configured for 4K/UHD and for two-sample-interleave, pass \c true for \c inIs425,
				to obtain the “425” crosspoint.

	See the \ref vidop-fs section for information about how to programmatically interrogate and configure Frame Stores.


	@subsection	widget_csc	ColorSpace Converter (CSC)

	A <b>ColorSpace Converter</b> widget represents the firmware entity that can convert YCbCr video into RGBA or vice-versa.
	-	::NTV2DeviceGetNumCSCs reports the number of CSC widgets that are available on a given device.
	-	CSC widgets are identified by ::NTV2_WgtCSC1, ::NTV2_WgtCSC2, etc.
	-	Each CSC has two input crosspoints:
		-	<b>Video Input</b>:  When this is sourced from another widget’s output crosspoint, and it’s receiving…
			-	YCbCr/YUV video, then the CSC will produce valid RGB[A] data on its RGBA output crosspoint.
			-	RGB[A] video, then the CSC will produce valid YCbCr data on its YUV output crosspoint.
		-	<b>Key Input</b>:  This supplies the alpha channel data for the CSC’s RGBA output.
		-	Call ::GetCSCInputXptFromChannel to obtain the ::NTV2InputCrosspointID for a CSC:
			-	Specify the CSC by ::NTV2Channel (e.g., use ::NTV2_CHANNEL3 for CSC 3).
			-	By default, the function returns the video input crosspoint. To obtain the alpha/key input
				crosspoint, pass \c true for \c inIsKeyInput.
	-	Each CSC has 3 output crosspoints:
		-	<b>YUV Video</b>:  This will produce valid YCbCr video data only when the CSC’s Video Input is receiving RGB[A] video data.
		-	<b>RGB Video</b>:	This will produce valid RGB[A] video data only when the CSC’s Video Input is receiving YCbCr video data.
		-	<b>Key YUV</b>:  This will produce valid YCbCr key data only when the CSC’s Video Input is receiving RGB[A] video data.
		-	Call ::GetCSCOutputXptFromChannel to obtain one of the CSC’s ::NTV2OutputCrosspointID values:
			-	Specify the CSC by ::NTV2Channel (e.g., use ::NTV2_CHANNEL3 for CSC 3).
			-	By default, the function returns the video output crosspoint.
				To obtain the <b>Key</b> crosspoint, pass \c true for \c inIsKey.
			-	By default, the function returns the <b>YUV</b> output crosspoint.
				To obtain the <b>RGB</b> crosspoint, pass \c true for \c inIsRGB.

	The \ref vidop-csc section has more information on CSC configuration.


	@subsection	widget_mixkey	Mixer/Keyer

	@image	html	cables-mixerkeyerwidget.png

	A <b>Mixer/Keyer</b> widget represents the firmware entity that can mix two YCbCr video sources into a single YCbCr
	raster (and key).
	-	::NTV2DeviceGetNumMixers reports the number of Mixer/Keyer widgets that are available on a given device.
	-	Mixer/Keyer widgets are identified by ::NTV2_WgtMixer1, ::NTV2_WgtMixer2, etc.
	-	Each Mixer/Keyer widget has four input crosspoints:
		-	<b>Foreground Inputs</b>:
			-	<b>Video</b>:  This determines the video that will appear in the foreground of the mix,
				and should be routed to a widget that produces YCbCr video.
			-	<b>Key</b>:  This determines the foreground key, and should be routed to another widget’s YCbCr output.
				Only the Y component is used — the Cb and Cr components are ignored.
			-	Call ::GetMixerFGInputXpt to obtain a foreground ::NTV2InputCrosspointID:
				-	Specify the ::NTV2Channel used. (The actual zero-based Mixer index that’s used will be half the
					ordinal value of ::NTV2Channel.)
				-	Pass \c false for \c inIsKey for the Video input;  pass \c true for the Key input.
		-	<b>Background Inputs</b>:
			-	<b>Video</b>:  This determines the video that will appear in the background,
				and should be routed to a widget that produces YCbCr video.
			-	<b>Key</b>:  This determines the background key, and should be routed to another widget’s YCbCr output.
				Note that only the Y component is used — the Cb and Cr components are ignored.
			-	Call ::GetMixerBGInputXpt to obtain a background ::NTV2InputCrosspointID:
				-	Specify the ::NTV2Channel used. (The actual zero-based Mixer index that’s used will be half the
					ordinal value of ::NTV2Channel.)
				-	Pass \c false for \c inIsKey for the Video input;  pass \c true for the Key input.
	-	Each Mixer/Keyer widget has two output crosspoints:
		-	<b>Video Output</b>:  This produces the mixed/keyed YCbCr video raster.
		-	<b>Key Output</b>:  This produces a YCbCr signal with the resulting mixed key data in the Y channel.
		-	Call ::GetMixerOutputXptFromChannel to obtain a Mixer’s ::NTV2OutputCrosspointID:
			-	Specify the ::NTV2Channel used. (The actual zero-based Mixer index that’s used will be half the
				ordinal value of ::NTV2Channel.)
			-	Pass \c false for \c inIsKey for the Mixer’s Video output;  pass \c true for the Mixer’s Key output.
	-	The Mixer is controlled using ::CNTV2Card API calls:
		-	<b>Mode</b>:
			-	Call CNTV2Card::GetMixerMode to determine the Mixer’s current mode.
			-	Call CNTV2Card::SetMixerMode to change the Mixer’s mode.
			-	Use ::NTV2MIXERMODE_FOREGROUND_ON to exclusively pass the foreground video and key to the Mixer output.
			-	Use ::NTV2MIXERMODE_FOREGROUND_OFF to exclusively pass the background video and key to the Mixer output.
			-	Use ::NTV2MIXERMODE_MIX to overlay the foreground video on top of the background video.
		-	<b>Input Controls</b>:
			-	Call CNTV2Card::GetMixerFGInputControl to determine the Mixer’s current foreground control value;
				call CNTV2Card::SetMixerFGInputControl to change it.
			-	Call CNTV2Card::GetMixerBGInputControl to determine the Mixer’s current background control value;
				call CNTV2Card::SetMixerBGInputControl to change it.
			-	Use ::NTV2MIXERINPUTCONTROL_FULLRASTER to …explain….
			-	Use ::NTV2MIXERINPUTCONTROL_SHAPED  to …explain….
			-	Use ::NTV2MIXERINPUTCONTROL_UNSHAPED  to …explain….
		-	<b>Mix Coefficient</b>:
			-	This is an unsigned 16-bit integer that determines the transparency of the foreground mask/key.
			-	Call CNTV2Card::GetMixerCoefficient to determine the Mixer’s current mix coefficient;
				call CNTV2Card::SetMixerCoefficient to change it.

	@note	The Mixer’s foreground and background inputs must be closely synchronized or the Mixer won’t be able to
			mix them, and if unlocked, its output will be garbled/invalid. Call CNTV2Card::GetMixerSyncStatus to
			determine if the Mixer is locked to both of its inputs and therefore if its output is locked/valid.


	<hr size="50px">
	@section	recipes_capture		Routing for Capture

	This section shows how to programmatically set up a device to receive video for several commmon scenarios.

	@par	SD/HD YCbCr

	TBD

	@par	SD/HD RGB

	TBD

	@par	SD/HD RGB Over-the-Wire Dual-Link

	TBD


	<hr size="50px">
	@section	recipes_playout		Routing for Playout

	This section shows how to programmatically set up a device for transmitting video for several commmon scenarios.

	@par	SD/HD YCbCr Playout From YCbCr Frame Buffer

	@code{.cpp}
		//	Example:  Set up FrameStore3 for RGB playout, route to SDI 3...
		theDevice.SetFrameBufferFormat (NTV2_CHANNEL3, NTV2_FBF_10BIT_YCBCR);
		theDevice.SetMode (NTV2_CHANNEL3, NTV2_MODE_OUTPUT);
		theDevice.Connect (NTV2_XptSDIOut3Input, NTV2_XptFrameBuffer3YUV);  // SDIOut3 <== FB3

		//	Or, more generically...
		NTV2Channel	chan = NTV2_CHANNEL3;
		NTV2FrameBufferFormat fbf = NTV2_FBF_10BIT_YCBCR;
		theDevice.SetFrameBufferFormat (chan, fbf);
		theDevice.SetMode (chan, NTV2_MODE_OUTPUT);
		theDevice.Connect (::GetSDIOutputInputXpt(chan), ::GetFrameBufferOutputXptFromChannel(chan, NTV2_IS_FBF_RGB(fbf))); // SDIOut3 <== FB3
	@endcode

	@par	SD/HD YCbCr Playout From RGB Frame Buffer

	@code{.cpp}
		//	Example:  Set up FrameStore3 for RGB playout, route to SDI 3...
		theDevice.SetFrameBufferFormat (NTV2_CHANNEL3, NTV2_FBF_ARGB);
		theDevice.SetMode (NTV2_CHANNEL3, NTV2_MODE_OUTPUT);
		theDevice.Connect (NTV2_XptCSC3VidInput, NTV2_XptFrameBuffer3RGB);  // CSC3 <== FB3RGB
		theDevice.Connect (NTV2_XptSDIOut3Input, NTV2_XptCSC3VidRGB);       // SDIOut3 <== CSC3RGB

		//	Or, more generically...
		NTV2Channel	chan = NTV2_CHANNEL3;
		NTV2FrameBufferFormat fbf = NTV2_FBF_ARGB;
		theDevice.SetFrameBufferFormat (chan, fbf);
		theDevice.SetMode (chan, NTV2_MODE_OUTPUT);
		theDevice.Connect (::GetCSCInputXptFromChannel(chan), ::GetFrameBufferOutputXptFromChannel(chan, NTV2_IS_FBF_RGB(fbf))); // CSC3 <== FB3RGB
		theDevice.Connect (::GetSDIOutputInputXpt(chan), ::GetCSCOutputXptFromChannel(chan)); // SDIOut3 <== CSC3RGB
	@endcode

	@par	HD RGB Playout Over 2 × 1.5G Dual-Link SDI From YCbCr Frame Buffer

	TBD

	@par	HD RGB Playout Over 1 × 3G Dual-Link SDI From YCbCr Frame Buffer

	TBD

	@par	HD RGB Playout Over 2 × 1.5G Dual-Link SDI From RGB Frame Buffer

	TBD

	@par	HD RGB Playout Over 1 × 3G Dual-Link SDI From RGB Frame Buffer

	@code{.cpp}
		//	Example:  Set up FrameStore3 for RGB playout, route to SDI 3...
		theDevice.SetFrameBufferFormat (NTV2_CHANNEL3, NTV2_FBF_ARGB);
		theDevice.SetMode (NTV2_CHANNEL3, NTV2_MODE_OUTPUT);
		theDevice.Connect (NTV2_XptDualLinkOut3Input, NTV2_XptFrameBuffer3RGB); // DLOut3 <== FB3RGB
		theDevice.Connect (NTV2_XptSDIOut3Input, NTV2_XptDuallinkOut3);         // SDIOut3 <== DLOut3
		theDevice.Connect (NTV2_XptSDIOut3InputDS2, NTV2_XptDuallinkOut3DS2);   // SDIOut3DS <== DLOut3DS

		//	Or, more generically...
		NTV2Channel	chan = NTV2_CHANNEL3;
		NTV2FrameBufferFormat fbf = NTV2_FBF_ARGB;
		theDevice.SetFrameBufferFormat (chan, fbf);
		theDevice.SetMode (chan, NTV2_MODE_OUTPUT);
		theDevice.Connect (::GetDLOutInputXptFromChannel(chan), ::GetFrameBufferOutputXptFromChannel(chan, NTV2_IS_FBF_RGB(fbf))); // DLOut3 <== FB3RGB
		theDevice.Connect (::GetSDIOutputInputXpt(chan, false), ::GetDLOutOutputXptFromChannel(chan, false)); // SDIOut3 <== DLOut3
		theDevice.Connect (::GetSDIOutputInputXpt(chan, true),  ::GetDLOutOutputXptFromChannel(chan, true));  // SDIOut3DS <== DLOut3DS
	@endcode

	@par	HD HFR YCbCr Playout Over 2 × 3G SDI From YCbCr Frame Buffer

	TBD

	@par	HD HFR YCbCr Playout Over 2 × 3G SDI From RGB Frame Buffer

	TBD

	@par	2K×1080 YCbCr Playout Over 2 × 3G SDI From YCbCr Frame Buffer

	TBD

	@par	HD HFR YCbCr Playout Over 2 × 3G SDI From RGB Frame Buffer

	TBD

	@par	UHD/4K 4:2:2 YCbCr Playout Over 4 × 3G SDI (“Squares”)

	TBD

	@par	UHD/4K 4:2:2 YCbCr Playout Over 4 × 3G SDI (“Two-Sample Interleave”)

	TBD

	@par	UHD/4K 4:2:2 YCbCr Playout Over 2 × 6G SDI (“Two-Sample Interleave”)

	TBD

	@par	UHD/4K 4:2:2 YCbCr Playout Over 1 × 12G SDI

	TBD


	<hr size="50px">
	@section	recipes_endtoend	Routing for Simultaneous Capture & Playout

	This section shows how to programmatically set up a device for transmitting input video with a variety of latencies.

	@par	SD/HD YCbCr E-E (Sub-Frame Latency)

	TBD

	@par	SD/HD YCbCr Frame Synchronizer (One-Frame Latency)

	TBD

	@par	HD E-E Mix RGBA Graphic Over Live Video

	with sub-frame latency
	TBD

	@par	HD HFR YCbCr E-E Over 2 × 1.5G Dual-Link SDI

	TBD

	@par	HD HFR YCbCr E-E Over 1 × 3G Dual-Link SDI

	TBD

	@par	E-E Over 2 × 3G SDI

	TBD

	@par	E-E Over 1 × 6G SDI

	TBD

**/
