/**
@page	recordplaytechniques		Capture and Playout Techniques

This page describes the basics of capturing and playing real-time video, then describes the two most popular methods:
-	<b>Ping-Pong</b>
-	<b>AutoCirculate</b>

@section	playoutbasics	Playout Basics

<i>Coming soon.</i>

<b>Playout Demos:</b>
-	\ref ntv2outputtestpattern
-	\ref ntv2player
-	\ref ntv2player4k

@section	capturebasics	Capture Basics

<i>Coming soon.</i>

@subsection	playoutinputdetect	Input Detection

<i>Coming soon.</i>

<b>Capture Demos:</b>
-	\ref ntv2capture
-	\ref ntv2capture4k

@section	aboutpingpong	Ping-Pong

The “ping-pong” method is a good choice when lower latency is required.
The illustration shows a scenario that captures incoming video frames, alters the captured frame in some way
(e.g., “burn” an image onto it), and then plays the altered frames.
One thread would, at every input VBI, flip the Input Frame between 0 and 1, and transfer the just-captured frame to the host.
The other thread would, at every output VBI, flip the Output Frame between 2 and 3, and transfer a finished frame from the
host to the off-screen buffer on the device. This should result in a three frame latency.

@image	html	pingpong.png

By getting “closer to the metal” with this technique, the application designer must manage every detail …
making DMA transfers at the right time, keeping the audio synchronized with the video, getting/setting timecode, etc.

Any unexpected delays or slow-downs in frame processing or DMA transfers will cause visual distortion.

Ping-Pong Capture/Playout Demos:
-	@subpage	ntv2llburn



@section	aboutautocirculate	AutoCirculate

AutoCirculate is an API in the ::CNTV2Card class which allows real-time video streaming on a non-real-time host operating system.
Video frames are buffered between the application software and the AJA device driver, and the driver is responsible for playing
out (or capturing) those frames at the correct time.

@image	html	ac-overview.png

AutoCirculate makes it easy to stream audio & video data into and out of your application.

AutoCirculate keeps ancillary data such as audio and timecode synchronized with the AutoCirculating video frames.

The AJA device driver performs the bulk of the work involved in streaming audio and video to/from the AJA hardware.
It helps to synchronize the audio with the video, detect dropped frames while streaming, time-stamps the frame data,
reads or writes embedded timecode, and manages many other details.

The AutoCirculate API coordinates the transfer of video and audio data between the AJA driver and the host application
as the driver circulates through its designated frame set (which is a contiguous block of frames in device SDRAM).
For recording, the driver cycles through its associated input frames, and on playback, the driver cycles through its
associated output frames. For example, an AutoCirculate capture using 7 frames would record each incoming frame one at
a time into device SDRAM in frames 0…6, 0…6, 0…6 <i>ad infínitum</i>, continually and repeatedly reusing those frame
“slots” in its memory. The key is for the host application to continually transfer the captured frames from device memory
into host memory fast enough to keep up with the incoming video being recorded on the device.

@note	AutoCirculate is intended for use in applications that require high reliability and that don’t require low latency.
		For low latency ingest or playout applications, the application must get “closer to the metal” and use another method,
		such as the \ref aboutpingpong method.


@subsection	autocirculatecapture	AutoCirculate Capture

Here’s an example of how AutoCirculate works in capture mode using 10 frame buffers:

@image	html	ac-capture.png

In this illustration, AutoCirculate is capturing, using 10 frame buffers.
Here, captured frames 6, 7, 8, 9, 0 and 1 have already been transferred into host memory (in that order),
while frame 2 is currently being transferred to the host, while frame 5 on the AJA device is currently being
overwritten by the incoming frame.

As each <b>Incoming Frame</b> streams into the AJA device, its image data (plus audio and ancillary data) is recorded
into the <b>Active Frame</b> of the device’s frame memory. 

When AutoCirculate is running, frames get transferred using Direct Memory Access (DMA) from the device frame memory to host memory.

The <b>Transfer Frame</b> — the frame being transferred to the host at the host’s request — “chases” the <b>Active Frame</b>,
with the gap between them called the <b>Buffer Level</b>.

To prevent “torn” or malformed images, the host application must ensure that the Transfer Frame never coincides with
the <b>Active Frame</b> being recorded.

Assuming a 29.97 fps full-frame rate, the AJA driver will bump the <b>Active Frame</b> to the next frame slot every 33 milliseconds.
As long as the host application that’s transferring frames takes less than 33 milliseconds (including the DMA transfer time) to
consume each frame, all will be well. If the host takes longer than 33 milliseconds to consume a frame, the <b>Transfer Frame</b>
will start to fall behind, and the <b>Buffer Level</b> will increase. If this is allowed to continue, the <b>Active Frame</b> will
overtake the <b>Transfer Frame</b>, which will result in “dropped” frames that never get transferred to the host.


AutoCirculate capture demos:
-	@subpage	ntv2capture
-	@subpage	ntv2ccgrabber
-	@subpage	ntv2qtpreview
-	@subpage	ntv2qtmultiinput


@subsection	autocirculateplayout	AutoCirculate Playout

@image	html	ac-playout.png

Here, AutoCirculate is in playout mode, using 10 frame buffers.
Frames 6, 7, 8, 9 and 0 already played through the output jack (in that order), while frame 1 is currently being played,
while frame 5 is being transferred from host memory to the AJA device.

In playout, the AJA device firmware continually streams the video content of the <b>Active Frame</b> buffer to the output jack.

When AutoCirculate is running, frames get transferred (DMA’d) from host memory to the <b>Transfer Frame</b> of the AJA device’s frame memory.

The <b>Active Frame</b> “chases” the <b>Transfer Frame</b>, with the frame gap between them called the <b>Buffer Level</b>.

To prevent repeated images, the host application must ensure that the <b>Transfer Frame</b> never collides with the <b>Active Frame</b> being played.

Assuming a 29.97 fps full-frame rate, the AJA driver will bump the <b>Active Frame</b> to the next frame slot every 33 milliseconds.
As long as the host application that’s transferring frames takes less than 33 milliseconds (including the DMA transfer time)
to produce each frame, all will be well. If the host takes longer than 33 milliseconds to produce a frame, the <b>Transfer Frame</b>
will start to fall behind, and the <b>Buffer Level</b> will decrease. If this is allowed to continue, the <b>Active Frame</b> will
overtake the <b>Transfer Frame</b>, which will result in “dropped” frames that will end up being played more than once.

AutoCirculate playout demos:
-	@subpage	ntv2player
-	@subpage	ntv2player4k
-	@subpage	ntv2ccplayer


@subsection	autocirculateinandout	AutoCirculate Capture and Playout

@image	html	ac-captureplayout.png

Here, AutoCirculate is simultaneously capturing from a device input and playing through a device output, while still using 10 frame buffers in all.

For this to work, two independent “channels” must be used, each with its own reserved range of frame
buffers on the device, each having its own <b>Active Frame</b>, <b>Transfer Frame</b> and <b>Buffer Level</b> measuring
the gap, if any, between them.

The client application would typically use two execution threads for performing the DMA transfers — one for capture, the other for playout.

@note	It’s possible to have other Frame Stores writing into (or reading from) device frame buffer memory being used by
		an AutoCirculate channel, its corresponding Frame Store, and the frame buffers being used. This can wreak havoc
		with the quality of the video being streamed. See the \ref vidop-fbconflict discussion for more details.

@note	It’s also possible to miscalculate the device frame buffer range being used for AutoCirculate such that the
		last frame or two encroach on the audio buffers. On capture, this can result in sporadically bad video frames
		and/or noise in the captured audio. On playout, this can cause sporadically bad video frames to be transmitted,
		and/or noise in the transmitted audio. See \ref audioclobber for more information.

AutoCirculate Capture/Playout Demos:
-	@subpage	ntv2burn
-	@subpage	ntv2burn4kquadrant
-	@subpage	ntv2ccgrabber
-	@subpage	ntv2fieldburn


@subsection	autocirculateapi	AutoCirculate API Functions

There are five principal member functions that comprise the AutoCirculate API in the CNTV2Card class:
-	CNTV2Card::AutoCirculateInitForInput
-	CNTV2Card::AutoCirculateInitForOutput
-	CNTV2Card::AutoCirculateStart
-	CNTV2Card::AutoCirculateStop
-	CNTV2Card::AutoCirculateTransfer
-	CNTV2Card::AutoCirculateGetStatus

In addition, there are several special-purpose methods that are available for more specialized applications, including:
-	CNTV2Card::AutoCirculateGetFrameStamp
-	CNTV2Card::AutoCirculatePause
-	CNTV2Card::AutoCirculateResume
-	CNTV2Card::AutoCirculateFlush


@subsection	autocirculateflow	Recommended Program Flow

@image	html	ac-captureflowchart.png

This illustrates the recommended program flow for using AutoCirculate to capture video and audio.
For a GUI application, the “Main” flow of execution on the left would handle the user interface implementation.
The “Wait for Quit Request” step would respond to user inputs and display capture/playout status.
For a command-line utility, the “Wait for Quit Request” box would implement a loop that sleeps, waiting for a
global “quit” flag to become logically “true” (and perhaps periodically emit some status information to the standard output stream).

Once the device has been acquired and configured, the main thread then creates and starts the capture thread.

The program flow surrounded by the dashed line is the capture thread. When it starts, CNTV2Card::AutoCirculateInitForInput
is called to set up the AutoCirculate parameters for a specific NTV2Channel, which allocates a contiguous block of frame
buffers on the card to be used by the AutoCirculate mechanism. At this point, it is started by calling CNTV2Card::AutoCirculateStart.
Once started, it remains in a loop, calling CNTV2Card::AutoCirculateGetStatus to determine if AutoCirculate is in the “running” state
and if at least one frame is ready to transfer. If so, AutoCirculateTransfer is called to transfer the captured frame to host memory;
otherwise the thread sleeps in CNTV2Card::WaitForInputVerticalInterrupt until the next VBI occurs.
This process continues until a global quit flag is set, at which point the thread calls CNTV2Card::AutoCirculateStop and exits.

After CNTV2Card::AutoCirculateStart is called, the AJA device’s <b>Active Frame</b> will automatically change at every VBI to cycle
continuously from the starting frame to the ending frame and back again until CNTV2Card::AutoCirculateStop is called.
CNTV2Card::AutoCirculateTransfer is called repeatedly to transfer a buffered video frame (plus any associated audio, timecode,
ancillary data, etc.) between the driver and the application. The <b>Active Frame</b>, buffer level, etc. are advanced automatically
by the AJA device driver.

CNTV2Card::AutoCirculateGetStatus is used to determine whether a given channel is currently AutoCirculating, and if so, to
report its current buffer level. It also supplies other data, such as its frame range (starting and ending frames) and its
<b>Active Frame</b>.

Because AutoCirculate is wholly implemented in the driver, and is completely independent of any ::CNTV2Card instance that started
it or that could be monitoring or controlling it, there is no provision to automatically stop AutoCirculating when any/all
::CNTV2Card instances have been destroyed. The driver will continue to AutoCirculate, blissfully unaware that nobody is monitoring
the activity. OEMs are encouraged to be good citizens and call CNTV2Card::AutoCirculateStop at exit to reduce unnecessary driver
activity.


@subsection	autocirculatechannels	AutoCirculate Channels

The ::NTV2Channel passed to CNTV2Card::AutoCirculateInitForInput (or CNTV2Card::AutoCirculateInitForOutput) identifies the
device \ref vidop-fs that is to be configured and operated by AutoCirculate in the device driver (i.e.
::NTV2_CHANNEL1 \c == 0 \c == FrameStore 1 \c == ::NTV2_WgtFrameBuffer1,
::NTV2_CHANNEL2 \c == 1 \c == FrameStore 2 \c == ::NTV2_WgtFrameBuffer2, etc.).

@image	html	ac-whichinterrupt.png

AutoCirculate is driven by vertical blanking interrupts (VBIs) received by the channel’s \ref vidop-fs. If these interrupts
aren’t received by the hardware, the driver’s ISR won’t get called, and AutoCirculate (for that channel) will be stuck.
-	<b>Playout</b> mode:
	-	The \ref vidop-fs need not be connected to anything. The device hardware has one clock that always runs,
		and delivers an output VBI to every enabled \ref vidop-fs that’s set to Playout mode.
	-	CNTV2Card::WaitForOutputVerticalInterrupt should theoretically never return False (time-out failure).
-	<b>Capture</b> mode:
	-	The \ref vidop-fs <i>MUST</i> be connected to an input widget (e.g., “SDI In”, “HDMI In”, “Analog In” widget) either…
		-	directly, or…
		-	indirectly through another widget (e.g., Dual-Link converter, CSC, etc.).
-	If AutoCirculate is stuck in the <b>Starting</b> phase, then interrupts weren’t being received by the \ref vidop-fs when the
	application called CNTV2Card::AutoCirculateStart.
-	If AutoCirculate is stuck in the <b>Running</b> or <b>Paused</b> state, then interrupts stopped being delivered to the
	\ref vidop-fs sometime after the application successfully called CNTV2Card::AutoCirculateTransfer.

<b>How Many Frames to Circulate?</b>

This choice can depend on a number of factors that each affect how many frames are available for buffering on the device:
-	The application’s frame-dropping tolerance;
-	The hardware devices it may need to run on (some devices have less SDRAM);
-	The largest video raster expected;
-	The frame buffer (pixel) format to be used.

To obtain the size of your host-based video buffer, in bytes (to accommodate a single frame), try…
-	::GetVideoActiveSize — returns the minimum number of bytes (including VANC lines for “tall” geometries);
-	::GetVideoWriteSize — this calls ::GetVideoActiveSize, but pads up to the nearest 4K page size multiple;
-	NTV2FormatDescriptor::GetTotalRasterBytes — gives the exact number (per-plane for planar formats).

To determine the maximum number of frame buffers a given device can accommodate for a given frame geometry and buffer format,
call ::NTV2DeviceGetNumberFrameBuffers.


@subsection	autocirculatepreload	Pre-Loading Frames For Playback

When AutoCirculate starts in playout mode (without yet transferring frames), the device firmware immediately starts playing
the contents of the <b>Active Frame</b> to the output jack, displaying whatever YCbCr/RGB data was in the device’s frame buffer memory.

If CNTV2Card::AutoCirculateTransfer has not been called, the <b>Active Frame</b> and <b>Transfer Frame</b> remain stuck at frame zero,
the <b>Buffer Level</b> remains at zero, and the Frames Dropped tally increments at the current frame rate.

To prevent displaying unpredictable frame(s) at playout startup (and to prevent frame drops caused by this initial frame starvation),
it’s best to “preload” one or more frames before calling CNTV2Card::AutoCirculateStart.

To do this, call CNTV2Card::AutoCirculateTransfer for each frame you wish to preload into the device frame buffer.
After each such call, the <b>Transfer Frame</b> will “bump” to the next frame slot, and the <b>Buffer Level</b> will increment.
After preloading, you can safely call CNTV2Card::AutoCirculateStart, and continue to transfer additional frames to the device,
with the goal of keeping the <b>Transfer Frame</b> ahead of the <b>Active Frame</b> being played by the hardware.

@subsection	autocirculateinterlace	Interlaced Versus Progressive Video

In capture mode, with a progressive video signal, immediately after the input VBI, the last-written video frame in the device’s
frame buffer is guaranteed to be fully-composed. With interlaced video, this is only true after every other VBI.
The following code snippet allows this phenomenon to be visualized:
@code{.cpp}
. . .
AUTOCIRCULATE_TRANSFER	xferInfo;
while (true)
{
	AUTOCIRCULATE_STATUS	status;
	mDevice.AutoCirculateGetStatus (NTV2_CHANNEL1, status);
	if (status.IsRunning())
	{
		if (status.HasAvailableInputFrame())
		{
			cout << '1';
			mDevice.AutoCirculateTransfer (NTV2_CHANNEL1, xferInfo);
		}
		else
			cout << '0';
	}	//	if A/C running
	mDevice.WaitForInputVerticalInterrupt (NTV2_CHANNEL1);
}	//	loop
. . .
@endcode

With interlaced video, the standard output stream will contain a \c ...010101010101... pattern, whereas progressive video
results in a \c ...111111111111... pattern.

When AutoCirculating interlaced video, the driver will not “bump” the <b>Active Frame</b> until it has been completely composed
(i.e., until immediately after the “Field 1” VBI occurs).

It is possible (and sometimes even desireable) to transfer each field of interlaced video separately, which can be done
by calling CNTV2Card::AutoCirculateTransfer every time through the loop (without checking the <b>Buffer Level</b>).
See the NTV2FieldBurn demonstration application for more details.

@subsection	autocirculatemon	Monitoring AutoCirculate Activity with “NTV2Watcher” Tool

\ref usingntv2watcher has an \ref inspectorac that shows AutoCirculate activity in near-real-time for all possible channels
on any AJA device attached to the host.

@image	html	watcher-inspector-ac.png

You can right-click in the AutoCirculate channel column to pop up a menu to control AutoCirculate activity on that channel.
This is handy for manually pausing, resuming, stopping or restarting AutoCirculate while your application runs.

**/
