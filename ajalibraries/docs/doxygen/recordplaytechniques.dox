/**
@page	recordplaytechniques		Capture and Playout Techniques

This page describes the basics of capturing and playing real-time video, then describes the two most popular methods:
-	<b>Ping-Pong</b>
-	<b>AutoCirculate</b>

@section	playoutbasics	Playout Basics

<i>Coming soon.</i>

<b>Playout Demos:</b>
-	\ref ntv2outputtestpattern
-	\ref ntv2player
-	\ref ntv2player4k

@section	capturebasics	Capture Basics

<i>Coming soon.</i>

@subsection	playoutinputdetect	Input Detection

<i>Coming soon.</i>

<b>Capture Demos:</b>
-	\ref ntv2capture
-	\ref ntv2capture4k



@section	aboutpingpong	Ping-Pong

The “ping-pong” method is a good choice when lower latency is required.
The illustration shows a scenario that captures incoming video frames, alters the captured frame in some way
(e.g., “burn” an image onto it), and then plays the altered frames.
One thread would, at every input VBI, flip the Input Frame between 0 and 1, and transfer the just-captured frame to the host.
The other thread would, at every output VBI, flip the Output Frame between 2 and 3, and transfer a finished frame from the
host to the off-screen buffer on the device. This should result in a three frame latency.

@image	html	pingpong.png

By getting “closer to the metal” with this technique, the application designer must manage every detail …
making DMA transfers at the right time, keeping the audio synchronized with the video, getting/setting timecode, etc.

Any unexpected delays or slow-downs in frame processing or DMA transfers will cause visual distortion.

The low-latency model can support either field or frame mode processing. In this model, a time-critical user-mode thread
is used to manage capture and/or playback in real-time.

For capture, full frames or separate fields can be transferred immediately after the VBI is received. Audio can be transferred
based on the actual number of audio samples that have been written into the device audio buffer.

For playback, frames written to the device frame buffer can be set to go on-air any time before the VBI. Field-mode processing
here is a little tricky, as once the first field is on-air, the second field will go on-air ready-or-not, so the application
must make some real-time decisions if it needs to drop a field. Low-latency client software can be written with a delay
parameter that would allow for some variation in the application’s video processing time while maintaining a fixed delay,
but it may not provide the reliability of the kernel queuing model.

Some relevant API calls:
-	Use CNTV2Card::WaitForInputVerticalInterrupt (capture) or CNTV2Card::WaitForOutputVerticalInterrupt (playout) to wait for
	the field VBI of interlaced video, or the frame VBI of progressive video.
-	CNTV2Card::WaitForInputFieldID can be used to wait for the frame VBI of interlaced video.
-	CNTV2Card::DMAReadFrame (capture) or CNTV2Card::DMAWriteFrame (playout) will transfer frame data.
-	CNTV2Card::DMAReadSegments (capture) or CNTV2Card::DMAWriteSegments (playout) can transfer one field’s lines to/from a
	half-height buffer on the host.

Ping-Pong Capture/Playout Demos:
-	@subpage	ntv2llburn


@section	aboutautocirculate	AutoCirculate

AutoCirculate is an API in the ::CNTV2Card class which allows real-time video streaming on a non-real-time host operating system.
Video frames are buffered between the application software and the AJA device driver, and the driver is responsible for playing
out (or capturing) those frames at the correct time.

@image	html	ac-overview.png

AutoCirculate makes it easy to stream audio & video data into and out of your application.

AutoCirculate keeps \ref ancillarydata such as \ref ancembeddedaudio and \ref anctimecode synchronized with the AutoCirculating
video frames.

The AJA device driver performs the bulk of the work involved in streaming audio and video to/from the AJA hardware.
It helps to synchronize the audio with the video, detect dropped frames while streaming, time-stamps the frame data,
reads or writes embedded timecode, and manages many other details.

The AutoCirculate API coordinates the transfer of video and audio data between the AJA driver and the host application
as the driver circulates through its designated frame set (which is a contiguous block of frames in device SDRAM).
For recording, the driver cycles through its associated input frames, and on playback, the driver cycles through its
associated output frames. For example, an AutoCirculate capture using 7 frames would record each incoming frame one at
a time into device SDRAM in frames 0…6, 0…6, 0…6 <i>ad infínitum</i>, continually and repeatedly reusing those frame
“slots” in its memory. The key is for the host application to continually transfer the captured frames from device memory
into host memory fast enough to keep up with the incoming video being recorded on the device.

@note	AutoCirculate is intended for use in applications that require high reliability and that don’t require low latency.
		For low latency ingest or playout applications, the application must get “closer to the metal” and use another method,
		such as the \ref aboutpingpong method.


@subsection	autocirculatecapture	AutoCirculate Capture

Here’s an example of how AutoCirculate works in capture mode using 10 frame buffers:

@image	html	ac-capture.png

In this illustration, AutoCirculate is capturing, using 10 frame buffers.
Here, captured frames 6, 7, 8, 9, 0 and 1 have already been transferred into host memory (in that order),
while frame 2 is currently being transferred to the host, while frame 5 on the AJA device is currently being
overwritten by the incoming frame.

As each <b>Incoming Frame</b> streams into the AJA device, its image data (plus audio and other \ref ancillarydata) is recorded
into the <b>Active Frame</b> of the device’s frame memory. 

When AutoCirculate is running, frames get transferred using Direct Memory Access (DMA) from the device frame memory to host memory.

The <b>Transfer Frame</b> — the frame being transferred to the host at the host’s request — “chases” the <b>Active Frame</b>,
with the gap between them called the <b>Buffer Level</b>.

To prevent “torn” or malformed images, the host application must ensure that the <b>Transfer Frame</b> never coincides with
the <b>Active Frame</b> being recorded.

Assuming a 29.97 fps full-frame rate, the AJA driver will bump the <b>Active Frame</b> to the next frame slot every 33 milliseconds.
As long as the host application that’s transferring frames takes less than 33 milliseconds (including the DMA transfer time) to
consume each frame, all will be well. If the host takes longer than 33 milliseconds to consume a frame, the <b>Transfer Frame</b>
will start to fall behind, and the <b>Buffer Level</b> will increase. If this is allowed to continue, the <b>Active Frame</b> will
overtake the <b>Transfer Frame</b>, which will result in “dropped” frames that never get transferred to the host. The dropped frame
count is available from the AUTOCIRCULATE_STATUS::GetDroppedFrameCount function. (See ::AUTOCIRCULATE_STATUS and
CNTV2Card::AutoCirculateGetStatus for more information.)

If the AutoCirculate channel was configured to capture audio, it will continuously monitor the incoming Audio/Video sync.
If it detects a difference of more than about 10 milliseconds, it will attempt to resync the audio to the video.
This resynchronization requires restarting the audio engine, which often results in a click or pop in the captured audio.

(See \ref anctimecode for more information about timecode capture and AutoCirculate.)


@subsubsection	autocirctimebudget		Per-Frame “Time Budget”

To prevent dropping frames, the application must stay within its per-frame “time budget”.

-	The video frame rate determines the per-frame “time budget”.
-	If the budget is exceeded long enough, the application <b><i>will</i></b> drop frames.
-	The “time budget” is spent doing three things:
	-	<b>DMA Transfer</b>: The elapsed time spent in the CNTV2Card::AutoCirculateTransfer function.
	-	<b>Processing</b>: The elapsed time from the moment CNTV2Card::AutoCirculateTransfer returns and the next
		time it’s about to be called (minus any <b>Waiting</b> time … see next item).
	-	<b>Waiting</b>: The time spent waiting for a new frame to become ready to transfer from the device.
		-	If the application has fallen behind (i.e. the <b>Buffer Level</b> exceeds 1), this wait time should be zero.
		-	If the application has caught up, this wait time will be non-zero.
-	It’s a good practice to add code that continuously measures the above quantities.
-	The sum of the <b>Processing</b> and <b>DMA Transfer</b> times must remain within the per-frame “time budget”
	(i.e. below frame time).
-	The proper action to take if the per-frame “time budget” is exceeded is application-dependent, and could include:
	-	log a message to the application or host logging facility;
	-	trigger an event;
	-	set an alarm;
	-	etc.
-	Occasionally exceeding the “time budget” for one or more frames can be tolerated…
	-	…if the application can catch up by sustained sub-frame-time DMA and frame processing, and…
	-	…the number of AutoCirculate device frame buffers is large enough to give the application
		time to catch up.



AutoCirculate capture demos:
-	@subpage	ntv2capture
-	@subpage	ntv2ccgrabber
-	@subpage	ntv2qtpreview
-	@subpage	ntv2qtmultiinput


@subsection	autocirculateplayout	AutoCirculate Playout

@image	html	ac-playout.png

Here, AutoCirculate is in playout mode, using 10 frame buffers.
Frames 6, 7, 8, 9 and 0 already played through the output jack (in that order), while frame 1 is currently being played,
while frame 5 is being transferred from host memory to the AJA device.

In playout, the AJA device firmware continually streams the video content of the <b>Active Frame</b> buffer to the output jack.

When AutoCirculate is running, frames get transferred (DMA’d) from host memory to the <b>Transfer Frame</b> of the AJA device’s frame memory.

The <b>Active Frame</b> “chases” the <b>Transfer Frame</b>, with the frame gap between them called the <b>Buffer Level</b>.

To prevent repeated images, the host application must ensure that the <b>Transfer Frame</b> never collides with the <b>Active Frame</b> being played.

Assuming a 29.97 fps full-frame rate, the AJA driver will bump the <b>Active Frame</b> to the next frame slot every 33 milliseconds.
As long as the host application that’s transferring frames takes less than 33 milliseconds (including the DMA transfer time)
to produce each frame, all will be well. If the host takes longer than 33 milliseconds to produce a frame, the <b>Transfer Frame</b>
will start to fall behind, and the <b>Buffer Level</b> will decrease. If this is allowed to continue, the <b>Active Frame</b> will
overtake the <b>Transfer Frame</b>, which will result in “dropped” frames that will end up being played more than once.

The \ref autocirctimebudget discussed in the \ref autocirculatecapture section applies equally for playout.

AutoCirculate assumes that the video and audio being transferred via CNTV2Card::AutoCirculateTransfer should be played together in-sync.
It continuously monitors the sync, and if it detects a difference of more than about 10 milliseconds, it will resync the audio to the video.
This resync involves restarting the audio engine, so a click or pop may be heard when it happens. The resync usually only happens when
frames are dropped, during which the audio will be disabled until newly-transferred data arrives. (See \ref audioplayout for more information.)

During a very long playback (occurring over many hours), if too many or too few samples are transferred, the sync may drift, which
may require a correction. A classic example of this would be playing a sequence of MP4 videos that have no notion of, say, the NTSC
5-frame cadence sequence. It can also easily happen when loop-playing a very short clip. One way to handle this is to track the number
of video frames and audio samples delivered to AutoCirculate over the long term, then add or drop samples in the breaks between clips.
Remember to reset the tracked frame and sample counts whenever the AUTOCIRCULATE_STATUS::GetDroppedFrameCount or
AUTOCIRCULATE_TRANSFER_STATUS::acFramesDropped value changes (increases). See \ref audiosamplecount for more information.

(See \ref anctimecode for more information about timecode playout and AutoCirculate.)


AutoCirculate playout demos:
-	@subpage	ntv2player
-	@subpage	ntv2player4k
-	@subpage	ntv2ccplayer


@subsection	autocirculateinandout	AutoCirculate Capture and Playout

@image	html	ac-captureplayout.png

Here, AutoCirculate is simultaneously capturing from a device input and playing through a device output, while still using 10 frame buffers in all.

For this to work, two independent “channels” must be used, each with its own reserved range of frame
buffers on the device, each having its own <b>Active Frame</b>, <b>Transfer Frame</b> and <b>Buffer Level</b> measuring
the gap, if any, between them.

The client application would typically use two execution threads for performing the DMA transfers — one for capture, the other for playout.

@note	It’s possible to have other Frame Stores writing into (or reading from) device frame buffer memory being used by
		an AutoCirculate channel, its corresponding Frame Store, and the frame buffers being used. This can wreak havoc
		with the quality of the video being streamed. See the \ref vidop-fbconflict discussion for more details.

@note	It’s also possible to miscalculate the device frame buffer range being used for AutoCirculate such that the
		last frame or two encroach on the audio buffers. On capture, this can result in sporadically bad video frames
		and/or noise in the captured audio. On playout, this can cause sporadically bad video frames to be transmitted,
		and/or noise in the transmitted audio. See \ref audioclobber for more information.

AutoCirculate Capture/Playout Demos:
-	@subpage	ntv2burn
-	@subpage	ntv2burn4kquadrant
-	@subpage	ntv2ccgrabber
-	@subpage	ntv2fieldburn


@subsection	autocirculateapi	AutoCirculate API Functions

There are five principal member functions that comprise the AutoCirculate API in the CNTV2Card class:
-	CNTV2Card::AutoCirculateInitForInput
-	CNTV2Card::AutoCirculateInitForOutput
-	CNTV2Card::AutoCirculateStart
-	CNTV2Card::AutoCirculateStop
-	CNTV2Card::AutoCirculateTransfer
-	CNTV2Card::AutoCirculateGetStatus

In addition, there are several special-purpose methods that are available for more specialized applications, including:
-	CNTV2Card::AutoCirculateGetFrameStamp
-	CNTV2Card::AutoCirculatePause
-	CNTV2Card::AutoCirculateResume
-	CNTV2Card::AutoCirculateFlush


@subsection	autocirculateflow	Recommended Program Flow

@image	html	ac-captureflowchart.png

This illustrates the recommended program flow for using AutoCirculate to capture video and audio.
For a GUI application, the “Main” flow of execution on the left would handle the user interface implementation.
The “Wait for Quit Request” step would respond to user inputs and display capture/playout status.
For a command-line utility, the “Wait for Quit Request” box would implement a loop that sleeps, waiting for a
global “quit” flag to become logically “true” (and perhaps periodically emit some status information to the standard output stream).

Once the device has been acquired and configured, the main thread then creates and starts the capture thread.

The program flow surrounded by the dashed line is the capture thread. When it starts, CNTV2Card::AutoCirculateInitForInput
is called to set up the AutoCirculate parameters for a specific NTV2Channel, which allocates a contiguous block of frame
buffers on the card to be used by the AutoCirculate mechanism. At this point, it is started by calling CNTV2Card::AutoCirculateStart.
Once started, it remains in a loop, calling CNTV2Card::AutoCirculateGetStatus to determine if AutoCirculate is in the “running” state
and if at least one frame is ready to transfer. If so, AutoCirculateTransfer is called to transfer the captured frame to host memory;
otherwise the thread sleeps in CNTV2Card::WaitForInputVerticalInterrupt until the next VBI occurs.
This process continues until a global quit flag is set, at which point the thread calls CNTV2Card::AutoCirculateStop and exits.

After CNTV2Card::AutoCirculateStart is called, the AJA device’s <b>Active Frame</b> will automatically change at every VBI to cycle
continuously from the starting frame to the ending frame and back again until CNTV2Card::AutoCirculateStop is called.
CNTV2Card::AutoCirculateTransfer is called repeatedly to transfer a buffered video frame (plus any associated audio, timecode,
\ref ancillarydata, etc.) between the driver and the application. The <b>Active Frame</b>, buffer level, etc. are advanced
automatically by the AJA device driver.

CNTV2Card::AutoCirculateGetStatus is used to determine whether a given channel is currently AutoCirculating, and if so, to
report its current buffer level. It also supplies other data, such as its frame range (starting and ending frames) and its
<b>Active Frame</b>.

Because AutoCirculate is wholly implemented in the driver, and is completely independent of any ::CNTV2Card instance that started
it or that could be monitoring or controlling it, there is no provision to automatically stop AutoCirculating when any/all
::CNTV2Card instances have been destroyed. The driver will continue to AutoCirculate, blissfully unaware that nobody is monitoring
the activity. OEMs are encouraged to be good citizens and call CNTV2Card::AutoCirculateStop at exit to reduce unnecessary driver
activity.


@subsection	autocirculatechannels	AutoCirculate Channels

The ::NTV2Channel passed to CNTV2Card::AutoCirculateInitForInput (or CNTV2Card::AutoCirculateInitForOutput) identifies the
device \ref vidop-fs that is to be configured and operated by AutoCirculate in the device driver (i.e.
::NTV2_CHANNEL1 \c == 0 \c == FrameStore 1 \c == ::NTV2_WgtFrameBuffer1,
::NTV2_CHANNEL2 \c == 1 \c == FrameStore 2 \c == ::NTV2_WgtFrameBuffer2, etc.).

@image	html	ac-whichinterrupt.png

AutoCirculate is driven by vertical blanking interrupts (VBIs) received by the channel’s \ref vidop-fs. If these interrupts
aren’t received by the hardware, the driver’s ISR won’t get called, and AutoCirculate (for that channel) will be stuck.
-	<b>Playout</b> mode:
	-	The \ref vidop-fs need not be connected to anything. The device hardware has one clock that always runs,
		and delivers an output VBI to every enabled \ref vidop-fs that’s set to Playout mode.
	-	CNTV2Card::WaitForOutputVerticalInterrupt should theoretically never return False (time-out failure).
-	<b>Capture</b> mode:
	-	The \ref vidop-fs <i>MUST</i> be connected to an input widget (e.g., “SDI In”, “HDMI In”, “Analog In” widget) either…
		-	directly, or…
		-	indirectly through another widget (e.g., Dual-Link converter, CSC, etc.).
-	If AutoCirculate is stuck in the <b>Starting</b> phase, then interrupts weren’t being received by the \ref vidop-fs when the
	application called CNTV2Card::AutoCirculateStart.
-	If AutoCirculate is stuck in the <b>Running</b> or <b>Paused</b> state, then interrupts stopped being delivered to the
	\ref vidop-fs sometime after the application successfully called CNTV2Card::AutoCirculateTransfer.

To obtain the size of your host-based video buffer, in bytes (to accommodate a single frame), try…
-	::GetVideoActiveSize — returns the minimum number of bytes (including VANC lines for “tall” geometries);
-	::GetVideoWriteSize — this calls ::GetVideoActiveSize, but pads up to the nearest 4K page size multiple;
-	NTV2FormatDescriptor::GetTotalRasterBytes — gives the exact number (per-plane for planar formats).

To determine the maximum number of frame buffers a given device can accommodate for a given frame geometry and buffer format,
call ::NTV2DeviceGetNumberFrameBuffers.


@subsection	autocirculatepreload	Pre-Loading Frames For Playback

When AutoCirculate starts in playout mode (without yet transferring frames), the device firmware immediately starts playing
the contents of the <b>Active Frame</b> to the output jack, displaying whatever YCbCr/RGB data was in the device’s frame buffer memory.

If CNTV2Card::AutoCirculateTransfer has not been called, the <b>Active Frame</b> and <b>Transfer Frame</b> remain stuck at frame zero,
the <b>Buffer Level</b> remains at zero, and the Frames Dropped tally increments at the current frame rate.

To prevent displaying unpredictable frame(s) at playout startup (and to prevent frame drops caused by this initial frame starvation),
it’s best to “preload” one or more frames before calling CNTV2Card::AutoCirculateStart.

To do this, call CNTV2Card::AutoCirculateTransfer for each frame you wish to preload into the device frame buffer.
After each such call, the <b>Transfer Frame</b> will “bump” to the next frame slot, and the <b>Buffer Level</b> will increment.
After preloading, you can safely call CNTV2Card::AutoCirculateStart, and continue to transfer additional frames to the device,
with the goal of keeping the <b>Transfer Frame</b> ahead of the <b>Active Frame</b> being played by the hardware.


@subsection	autocirculateinterlace	Interlaced Versus Progressive Video

In capture mode, with a progressive video signal, immediately after the input VBI, the last-written video frame in the device’s
frame buffer is guaranteed to be fully-composed. With interlaced video, this is only true after every other VBI.
The following code snippet allows this phenomenon to be visualized:
@code{.cpp}
. . .
AUTOCIRCULATE_TRANSFER	xferInfo;
while (true)
{
	AUTOCIRCULATE_STATUS	status;
	mDevice.AutoCirculateGetStatus (NTV2_CHANNEL1, status);
	if (status.IsRunning())
	{
		if (status.HasAvailableInputFrame())
		{
			cout << '1';
			mDevice.AutoCirculateTransfer (NTV2_CHANNEL1, xferInfo);
		}
		else
			cout << '0';
	}	//	if A/C running
	mDevice.WaitForInputVerticalInterrupt (NTV2_CHANNEL1);
}	//	loop
. . .
@endcode

With interlaced video, the standard output stream will contain a \c ...010101010101... pattern, whereas progressive video
results in a \c ...111111111111... pattern.

When AutoCirculating interlaced video, the driver will not “bump” the <b>Active Frame</b> until it has been completely composed
(i.e., until immediately after the “Field 1” VBI occurs).

It is possible (and sometimes even desireable) to transfer each field of interlaced video separately, which can be done
by calling CNTV2Card::AutoCirculateTransfer every time through the loop (without checking the <b>Buffer Level</b>).
See the NTV2FieldBurn demonstration application for more details.


@subsection  autocirculatelowlatency  Latency and Field-Based Operation Considerations

The NTV2 firmware and AutoCirculate have always been frame-based. Field mode hasn’t been added to AutoCirculate, since the
kernel queuing model it uses doesn’t really support low-latency well. It is very good at reliably capturing and playing
frames without dropping, as long as the queue is large enough to absorb user-mode latency. The kernel queue is managed
once per frame just after the video VBI. This gives the client software an entire frame-time to program the hardware for
the next frame.

For capture, the frame written to the device frame buffer during the previous frame time is available for transfer after
the vertical interrupt is received. However, audio can’t be transferred immediately, since audio is captured continuously,
and all audio for the previous frame may not have been flushed to the device frame buffer yet. For this reason, AJA usually
recommends transferring video and audio when there’s at least two frames in the queue — which obviously isn’t good for
low-latency applications.

For playback, when the frame interrupt is received, the frame to display after the next VBI must be set in the hardware.
Since this is a whole frame early, you essentially end up with two frames in the queue for playback as well. This is why
we wrote the \ref ntv2llburn, a low-latency demo that works without AutoCirculate.

<b>How many frames to circulate?</b> This choice can depend on a number of factors that each affect how many frames are
available for buffering on the device:
-	The application’s frame-dropping tolerance;
-	The hardware devices it may need to run on (some devices have smaller amounts of SDRAM);
-	The largest video raster expected;
-	The frame buffer (pixel) format to be used.


@subsection	autocirculatemon	Monitoring AutoCirculate Activity with \ref usingntv2watcher Tool

\ref usingntv2watcher has an \ref inspectorac that shows AutoCirculate activity in near-real-time for all possible channels
on any AJA device attached to the host.

@image	html	watcher-inspector-ac.png

You can right-click in the AutoCirculate channel column to pop up a menu to control AutoCirculate activity on that channel.
This is handy for manually pausing, resuming, stopping or restarting AutoCirculate while your application runs.

While AutoCirculate is paused, you can inspect, in great detail…
-	the captured (or queued) per-frame timecodes (in the \ref inspectorac).
-	the captured (or queued) video frames (using the \ref inspectorframebuffer).
-	the captured (or queued) audio samples (using the \ref inspectoraudio).
-	the captured (or queued) \ref ancillarydata (using the \ref inspectoranc).

**/
